\documentclass{article}
\usepackage[margin=1.25in]{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}
\pagestyle{fancy}
\lhead{} \rhead{}
\chead{Splice Machine Technical Design Document}
\lfoot{Splice Machine, Inc. Proprietary and Confidential}
\cfoot{}
\rfoot{\thepage\\}

\begin{document}

\title{Explain Trace and Explain Plan}
\author{Jun Yuan}
\maketitle
\author
\thispagestyle{fancy}

\section{Revision History}
\begin{enumerate}
  \item (6/19/2014) - (JY) Initial version
  \item (6/23/2014) - (JY) Incoporate Gene's comments
\end{enumerate}
\section{Background}
\subsection{Terminology}
Explain plan: we define an explain plan as a logical execution plan generated by an optimizer for a SQL DML statement, such as insert, update, delete.\\

\noindent
Explain trace: we define an explain trace as a collection of information for a SQL execution, including physical execution plan and various runtime statistics.

\subsection{Overview}
One of the important tasks of SQL tuning is to verify that the execution plan generated by an optimizer is efficient. A database administrator needs a readable presentation of execution plan (logical and physical) to quickly identify the problem, and repeat the following steps to improve performance:
\begin{enumerate}
  \item	Turn on SQL trace, and execute a query
  \item	Examine explain trace and identify performance problems
  \item	Modify query by enabling or disabling an index, choosing an efficient join strategy, deciding an optimal join order, etc.
  \item	Run explain plan to check whether the optimizer generates desired execution plan for the modified query. If not, go back to step 3.
\end{enumerate}
\noindent
A splice machine developer can utilize explain trace to better understand performance characteristics of various operations, and identify the hot spot for a SQL execution.

\section{Requirements}
\subsection{P0 Requirements}
\begin{itemize}
  \item Output an operation tree that was actually executed by splice. The operation tree should include important information from the original SQL statement (table name, index name, join predicate, scan filter, etc.)
  \item Calculate statistics for each operation, including I/O, CPU, etc.
  \item Present execution plan to ij and UI console with tunable level of details
  \item Include statistical information in explan plan
\end{itemize}

\section{Design}
\subsection{Explain Tables}
If explain traced is turned on, runtime statistics are collected into the following three explain tables under SYS schema.
\begin{itemize}
  \item SYSSTATEMENTHISTORY: stores information for executed state
  \item SYSOPERATIONHISTORY: stores information for executed splice operations
  \item SYSTASKHISTORY: store information for tasks that execute splice operations
\end{itemize}
Once an EXPLAINTRACE for a SQL statement completes successfully, runtime statistics is stored in explain tables until the tables are purged. To purge explain tables, run the following command.
\begin{lstlisting}
CALL SYSCS_UTIL.PURGE_XPLAIN_TRACE();
\end{lstlisting}
\subsection{Enabling and Disabling Explain Trace}
Explain trace can be turned manually for a connection by running the following command from ij console:
\begin{lstlisting}
EXPLAINTRACE ON;
\end{lstlisting}
Explain trace will be turned on to trace all subsequent SQL statements until a user turns off explain trace by running 
\begin{lstlisting}
EXPLAINTRACE OFF;
\end{lstlisting}
Explain trace can be turned on for a SQL statement by running the following command
\begin{lstlisting}
EXPLAINTRACE [IN JSON] FOR ?SQL Statement?; 
\end{lstlisting}
Explaintrace turns on runtime statistics, executes the SQL, collects runtime statistics, and stores statistics in explain tables under SYS schema. 

\noindent
A user can specify the output format for an execution plan. By default, splice outputs an execution plan in an annotated tree format. If \lq IN JASON\rq\,is specified, splice outputs the execution plan as a JSON string.

\noindent
When explaintrace command completes, runtime statistics is turned off automatically. The SQL statement and its unique ID can be found in SYS.SYSSTATEMENTHISTORY table.  
\subsection{Auto Trace}
To better trouble-shooting a long-running analytic SQL, explain trace will be automatically turned on if a query runs on a table with more than 3 regions. Auto trace is turned on by default. To disable it, run the following command:

\begin{lstlisting}
CALL SYSCS_UTIL.SYSCS_SET_AUTO_TRACE(0);
\end{lstlisting}
\noindent
To re-enable auto trace, run the following command:
\begin{lstlisting}
CALL SYSCS_UTIL.SYSCS_SET_AUTO_TRACE(1);
\end{lstlisting}
\subsection{Display Explain Trace}
A user can query SYS.SYSSTATEMENTHISTORY or run the following system procedure to query statement ID of the most recently traced SQL statement.
\begin{lstlisting}
CALL SYSCS_UTIL. SYSCS_GET_XPLAIN_STATEMENTID();
\end{lstlisting}
A user can request an execution plan for a previous query by running the following system procedure and specifying a statement ID, detail level (0, or 1), and a format (?tree? or ?Json?).
\begin{lstlisting}
CALL SYSCS_UTIL.SYSCS_GET_XPLAIN_TRACE(statementId,level,format);
\end{lstlisting}
\subsection{Collect Runtime Statistics}
When explain trace is turned on, splice records information about the SQL execution into explain tables.
\begin{itemize}
  \item During byte code generation, readable format of scan filter and join clause are extract from a parse tree into an activation object.
  \item When an operation tree is being constructed, extract readable format of scan filter and join clause into the operation tree.
  \item During SQL execution, an operation tree is pushed to region servers. When a region finishes execution of an operation tree, statistics for each operation execution is recorded into SYSXPLAIN\_SYSTASKHISTORY table.
  \item When a SQL statement finishes execution, information for the SQL statement is recorded in SYSXPLAIN\_SYSSTATEMENTHISTORY table. Information for the operation tree is recorded in SYSXPLAIN\_SYSOPERATIONHISTORY table.
\end{itemize}
Three categories of runtime statistics are collected during a SQL statement execution:
\begin{itemize}
  \item Timing
  \item I/O
  \item	Buffer usage
\end{itemize}
\subsubsection{Timing}
Timer classes are implemented to start timing, stop timing, and count the number of events (a read or a write). Various timing statistics (in milliseconds) are calculated for different splice operations:
\begin{itemize}
  \item Start and stop timestamps for an operation
  \item Total wall/user/cpu time for a splice operation
  \item Local scan wall/user/cpu time for a region scan
  \item Remote scan wall/user/cpu time for scanning a remote region
  \item Remote get wall/user/cpu time for Hbase Get operations
  \item Process wall/user/cpu time for all splice operation
  \item Total time a task waits in queue
  \item Write wall/user/cpu time
  \item Network write wall/user/cpu time
  \item Thread write wall/user/cpu time
\end{itemize}
\subsubsection{I/O}
Splice region scanner and client scanner are instrumented to calculate runtime statistics for local and remote scan.
\begin{itemize}
  \item Number of rows and bytes for a region scan
  \item Number of rows and bytes for a remote scan
\end{itemize}
Write pipeline collects write statistics.
\begin{itemize}
  \item Write rows and bytes
  \item Number of partial write failures
  \item Number of rejected writes
  \item Number of write batches
  \item Number of write failures
\end{itemize}
\subsubsection{Buffer Usage}
The buffer fill ratios for grouped aggregate and distinct scalar aggregate operations are collected.
\subsection{Trace Splice Operations}
All working operations need to be traced, including
\begin{itemize}
  \item AnyOperation
  \item BroadcaseJoinOperation
  \item CallStatementOperation
  \item DeleteOperation
  \item DistinctScanOperation
  \item GroupedAggregateOperation
  \item IndexRowToBaseRowOperation
  \item InsertOperation
  \item MergeSortJoinOperation
  \item NestedLoopJoinOperation
  \item NormalizeOperation
  \item OnceOperation
  \item ProjectRestrictOperation
  \item RowCountOperation
  \item RowOperation
  \item ScalarAggregateOperation
  \item TableScanOperation
  \item ScrollInsensitiveOperation
  \item SortOperation
  \item UnionOperation
  \item UpdateOperation
  \item Import
  \item Create Index
  \item Alter Table Drop Column
\end{itemize}
\subsection{XPlain Trace Output}
SYSCS\_UTIL.SYSCS\_GET\_XPLAIN\_TRACE analyzes the three explain tables.
\begin{itemize}
  \item Re-construct the query execution plan by connecting parent-child operations
  \item Aggregate statistics for an operation if it is executed by multiple tasks
  \item Output execution plan in text or JSON format.
\end{itemize}
Execution plan can be displayed in 2 different levels. The following is TPCH query 1 and its explain trace output in summary level.
\begin{lstlisting}
------------------------------
TPCH Query 1
------------------------------
select
	l_returnflag,
	l_linestatus,
	sum(l_quantity) as sum_qty,
	sum(l_extendedprice) as sum_base_price,
	sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
	sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
	avg(l_quantity) as avg_qty,
	avg(l_extendedprice) as avg_price,
	avg(l_discount) as avg_disc,
	count(*) as count_order
from
	lineitem
where
	l_shipdate <= date({fn TIMESTAMPADD(SQL_TSI_DAY, -90, cast('1998-12-01 00:00:00' as timestamp))})
group by
	l_returnflag,
	l_linestatus
order by
	l_returnflag,
	l_linestatus;

------------------------------
Explain Trace Output
------------------------------

|--ScrollInsensitive[TWT=455000]                                                                                                                                                   
   |--Sort[TWT=59605000]                                                            
      |--ProjectRestrict[TWT=59272000]                                                                                                                                      
         |--GroupedAggregate[TWT=105924786000]
            |--ProjectRestrict[TWT=1752172201]                                                                                                                         
               |--BulkTableScan(table=1664)[Scan filter:(L_SHIPDATE[0:7] <=  date(TIMESTAMPADD(1998-12-01 00:00:00.0, 4, -90))), LSR=6001215]
----------------------------------------------------------------------------------
TWT: Total Wall Time      	
LSR: Local Scan Row
\end{lstlisting}
The following is a detailed view of an execution plan for a query on Guavus dataset.
\begin{lstlisting}
------------------------------
Query
------------------------------
select count(*) from si

------------------------------
Execution Plan
------------------------------

|--ScrollInsensitive[TWT=8352000, RSR=1,IR=1,OR=1]                                            
   |--ProjectRestrict[TWT=7346000, IR=1,OR=1]                                        
      |--ScalarAggregate(*)[TWT=348451294000, WR=6]
         |--ProjectRestrict[TWT=11093777691, IR=25000000,OR=250]
            |--BulkTableScan(table=1184)
               |--RegionScan[LSR=3116576,LSB=754839650,LSWT=7609122836,OR=3116576]     
               |--RegionScan[LSR=3123099,LSB=642905136,LSWT=6130431981,OR=3123099]
               |--RegionScan[LSR=3124035,LSB=759507180,LSWT=11509405825,OR=3124035]
               |--RegionScan[LSR=3124645,LSB=643219225,LSWT=9980086908,OR=3124645]
               |--RegionScan[LSR=6251488,LSB=1286878358,LSWT=13399657831,OR=6251488]
               |--RegionScan[LSR=6260157,LSB=1288712431,LSWT=13385258392,OR=6260157]
------------------------------------------------------------------------------
IR: INPUTROWS        LSB: LOCALSCANBYTES 
LSR: LOCALSCANROWS   LSWT: LOCALSCANWALLTIME
OR: OUTPUTROWS 	     TWT: TOTALWALLTIME                    
\end{lstlisting}
A detailed view as the above shows details of region scans, such as scanned rows and bytes. A database administrator can utilize region scan information to identify performance problems for a parallel operation such as aggregate. For example, the above example shows that two of the regions are 2x larger than other 4 regions. Splitting the two large regions can improve performance of the above SQL statement.

\noindent
The management web UI can get an execution plan in JSON format.

\subsection{Explain Plan}
Add a new command ?explain? to ij. To get an explain plan for a SQL statement, run 
\begin{lstlisting}
explain statement;
\end{lstlisting}
The statement will be parsed and optimized by Derby as usual. A query plan will be output. For example:
\begin{lstlisting}
splice> explain select * from t t1 where t1.i < (select max(i) from t  t1);
Plan                                                                                                                            
---------------------------------------------------------------------------------
ScrollInsensitiveResultSetNode ({n=8})                                                                                          
  ProjectRestrictNode ({n=7})                                                                                                   
    ProjectRestrictNode ({n=6})                                                                                                 
      FromBaseTable ({quals=[(T1.I[5:1] < subq=4)], n=5, table=T,1184})                                                         
                                                                                                                                
Subquery n=4: expression?=true, invariant?=true, correlated?=false                                                              
  ProjectRestrictNode ({n=4})                                                                                                   
    GroupByNode ({n=3})                                                                                                         
      ProjectRestrictNode ({n=2})                                                                                               
        ProjectRestrictNode ({n=1})                                                                                             
          FromBaseTable ({n=0, table=T,1184})                                                                                   

11 rows selected

\end{lstlisting}
\section{Assumptions}
Displaying an easy-to-read execution plan for a complex query is a challenge. The SQL statement can be hundreds of lines with many levels of nested sub-queries. Though we have not experimented with a very large and complex SQL statement using the proto-type implementation, we can imagine it will take some effort for a database administrator to read an execution plan produced for such queries.

\noindent
The proposed solution outputs an execution plan with statistics as text to ij console. The limited console size can make the output hard to read. We expect that a graphical management web UI can visualize an execution plan and make reading an execution a much more fun.


\section{Outstanding Issues}

\begin{itemize}
  \item Show different views for explain trace
  \item Integration with management web UI
  \item Provide metrics for data and CPU skews
\end{itemize}

\section{Impacts}

\subsection{Impact on QA}
Explain trace is not expected to impact other features, so no change is required for existing test cases. 
Any special callouts for QA tests

\subsection{Impact on Documentation} 
Requires documentation on the following
\begin{itemize}
  \item Usage of explain trace/plan
  \item Meaning of metrics
  \item Explanation of splice operation
  \item How to interpret an explain plan/trace with real examples.
\end{itemize}

\subsection{Impact on Upgrades}

The upgrade script needs to create explain tables under SYS schema.

\subsection{Other Known Impacts}

N/A

\end{document}
