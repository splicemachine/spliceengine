\section{Recovery, Flashback, and Replication Problem Statement}
Transactional and Analytical databases are required to provide a backup and
recovery mechanism.  Before jumping into a review of approaches, it is
important to split Recovery and Replication into clear demarcated product
features.


\subsection{Point in Time Full Backup (Cold)}
A Cold, Point in Time Full Backup will take a full snapshot of the current state
of the database while the database is either unavailable for writes or
physically shutdown.  This approach is difficult for large-scale
distributed RDBMS's for the following reasons

\begin{enumerate}
	\item Most relational databases for transactional and analytical workloads are
	increasingly fully utilized during the entire day and require 3 to 5 9's
	uptime.
	\item Cycling a distributed database is a time consuming process
	as the node size increases.
	\item As data sizes increases over time, each backup will consume more
	resources (Disk, CPU).
	\item A user or application that corrupts or inadvertantly writes/deletes data
	after a backup occurs.
\end{enumerate}

\subsection{Point in Time Full Backup (Hot)}
A Hot, Point in Time Full Backup will take a full snapshot of the current state
of the database while the database is available to reads and writes.  This
approach removes the first two challenges from the cold backup but still
requires significant resources to perform the backup and does not allow for a
smaller data loss horizon.  Clearly, if no backups have ever been run on the
system, a full backup will always be required.

\subsection{Point in Time Incremental Backup (Cold)}
This approach will reduce the amount of resources used to perform the backup but
still effects database availability.  

\subsection{Point in Time Incremental Backup (Hot)}
Point in Time Incremental Backups allow smaller, less resource intensive backups
to be combined to provide an accurate view of the database.

\subsection{Flashback}

Oracle has branded the ability to immediately recover to a point in time as a
\emph{FlashBack}.  Please see
\url{http://www.oracle.com/technetwork/database/features/availability/flashback-overview-082751.html}.

This feature clearly uses SnapshotIsolation to achieve the capability of quickly
reverting databases and viewing changes made the database.

\subsubsection{Database Flashback}
This feature restores the entire database to a point in time without using
backups but instead using timestamp based logging of data.

\subsubsection{Table Flashback}

This feature restores the table and related objects back to a user specified
date and time.

\subsubsection{Drop Flashback}

Recovers from a dictionary level drop/

\subsubsection{Transaction Flashback}

Recovers from all edits made during a transaction.

\subsubsection{Transaction Query Flashback}

Query allows a user to visualize all data changed during a supplied transaction.

\subsubsection{Query Flashback}

Allows a user to execute a query against the database based on its snapshot
looked in the past.

\subsubsection{Query Versions Flashback}

Display all versions of data in a data set.

\subsection{Replication}

\subsubsection{WAL Replication In Process Synchronous, Master-Slave}

\subsubsection{WAL Replication In Process Asynchronous, Master-Slave}

\subsubsection{WAL Replication Enqueued Asynchronous, Master-Slave}

\subsubsection{WAL Replication In Process Synchronous, Master-Master}

\subsubsection{WAL Replication In Process Asynchronous, Master-Master}

\subsubsection{WAL Replication Enqueued Asynchronous, Master-Master}


\subsection{HBase Snapshots}

HBase Snapshots allow for a table to be captured for a specific point of time
by forcing a flush to the regions involved and capturing the regions store
files and keeping an archived copy of those store files when compaction occurs. 

\url{http://blog.cloudera.com/blog/2013/03/introduction-to-apache-hbase-snapshots/}

\url{http://blog.cloudera.com/blog/2013/06/introduction-to-apache-hbase-snapshots-part-2-deeper-dive/}

\subsection{HBase Snapshots}

\section{Splice Machine Backup and Recovery Design}

Backups should look, feel, and perform similar to other existing Splice Machine
Operations.  It is critical that snapshots are incorporated into our exisiting
resource management framework to allow the database to back itself up gradually
while still being highly available and performant.

\subsection{HBase HFile Governance, Backup Schema and Timestamp Capture}

Splice Machine backups and recovery require HFile governance, a functional
snapshot schema, and snapshot isolation timestamp mapping.

There is a need for backups to record their activity to understand when they
were issued and what their effective timestamp is based on the submission.
 
\begin{center}
\begin{tabular}{|l|c|p{5cm}|}
				\hline
				\bf{Column}							&	\bf{Data Type}	&	\bf{Description} \\ \hline
				Backup Id							&	Long			&	A unique backup identifier generated by \\ \hline 
				Backup Transaction Id				& 	Long			& 	Corresponding
				transactional cutpoint generated by the transaction oracle. \\ \hline 
				Backup Timestamp				   &	Timestamp		&	The system timestamp of
				the attempted backup.
				\\
				\hline 
				Backup Status						&	Varchar			& 	The status of
				thebackup(Succeeded,Aborted,Active).
				\\
				\hline
				Filesystem						&	Varchar			& 	The filesystem backed up to.
				\\
				\hline

\end{tabular}
\end{center}


For isolation timestamp mapping, it is proposed that a new table exist for meta


\begin{center}
\begin{tabular}{|l|c|p{5cm}|}
				\hline
				\bf{Column}							&	\bf{Data Type}	&	\bf{Description} \\ \hline
				Flashback Id							&	Long			&	A unique flashback identifier generated by \\
				\hline 
				Flashback Begin Transaction Id				& 	Long			& 	Corresponding
				transactional cutpoint selected to rollback to in time. \\ \hline 
				Flashback End Transaction Id				& 	Long			& 	Corresponding
				transactional cutpoint to begin forward transactions in time. \\
				\hline 
\end{tabular}
\end{center}

The governance of HFiles during compaction (putting multiple files together to
become a single file to reduce I/O needs) will need be strictly monitored. 
Whenever a compaction uses a file where its maximum timestamp is greater then
the timestamp of the last full or incremental backup, it will need to be 
$T_{max} > T_{lastBackup}$ then


\subsection{Point in Time Full Backup (Hot)}

To perform a full backup,

\begin{lstlisting}[frame=single,captionpos=b,language=SQL,caption=Procedure to
Perform a Full Backup] 
backup database full Filesystem;
\end{lstlisting}

\begin{enumerate}
	\item Capture backup timestamp $T_{backup}$ and verify no active backups
	running.
	\item Write Backup Record to Splice Backup Table with current system timestamp
	and flag set to full backup.
	\item Submit CreateFullBackupJob 
	\begin{enumerate}
	\item Scan all regions for all tables in Splice Machine
	\item Submit CreateFullBackupTask to each region in the backup resource queue
	\begin{enumerate}
	\item Perform synchonous region flush 
	\item Perform a Start Region Operation (Read Lock)
	\item Validate Begin and End Keys for task are correct for each region, if not
	fail the task for resubmission to new split regions
	\item Capture the set of Data Files for each Region
	\item Copy those files to the external filesystem supplied (HDFS, scp, etc.)
	\item Finish Region Operation
	\item Complete Task
	\end{enumerate}
	\item On Failure, retry.
	\item After all complete, finish the job
	\end{enumerate}
	\item Mark the backup as complete
\end{enumerate}


\subsection{Point in Time Incremental Backup (Hot)}

To perform an incremental backup,
	
\begin{lstlisting}[frame=single,captionpos=b,language=SQL,caption=Procedure to
Perform an Incremental Backup] 
backup database incremental Filesystem;
\end{lstlisting}

\begin{enumerate}
	\item Capture backup timestamp $T_{backup}$, last backup
	timestamp $T_{last_backup}$, and verify no active backups running.
	\item Write Backup Record to Splice Backup Table with current system timestamp
	and flag set to incremental backup.
	\item Submit CreateIncrementalBackupJob 
	\begin{enumerate}
	\item Scan all regions for all tables in Splice Machine
	\item Submit CreateIncrementalBackupTask to each region in the backup resource
	queue
	\begin{enumerate}
	\item Perform synchonous region flush 
	\item Perform a Start Region Operation (Read Lock)
	\item Validate Begin and End Keys for task are correct for each region, if not
	fail the task for resubmission to new split regions
	\item Capture the set of Data Files for each Region
	\item Copy those files to the external filesystem supplied (HDFS, scp, etc.)
	\item Finish Region Operation
	\item Complete Task
	\end{enumerate}
	\item On Failure, retry.
	\item After all complete, finish the job
	\end{enumerate}
	\item Mark the backup as complete
\end{enumerate}

\subsection{Splice Machine Flashback Design}
Splice Machine's flashback capabilty

\subsubsection{Database Flashback}
Database level flashback



\subsubsection{Table Flashback}

\subsubsection{Drop Flashback}

\subsubsection{Transaction Flashback}

\subsubsection{Transaction Query Flashback}

\subsubsection{Query Flashback}

\subsubsection{Query Versions Flashback}

\subsubsection{Query Versions Flashback}

\subsubsection{Audit Trail Flashback}


\section{Splice Machine Replication Design}


%End Backup Chapter
