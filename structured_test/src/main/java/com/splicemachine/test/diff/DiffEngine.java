package com.splicemachine.test.diff;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.apache.commons.io.FileUtils;

import com.splicemachine.test.utils.TestUtils;
import com.splicemachine.test.verify.Verifier;
import com.splicemachine.test.verify.VerifyReport;

import difflib.DiffUtils;
import difflib.Patch;

/**
 * Static utility to determine and report file differences
 */
public class DiffEngine implements Verifier {
	private final String testOutputDir;
	private final List<String> derbyFilter;
	private final List<String> spliceFilter;

    /**
     * @param testOutputDirectory the directory in which to look for SQL output scripts
	 * @param derbyOutputFilter any optional output line filters to apply to Derby output.
	 * @param spliceOutputFilter any optional output line filters to apply to Splice output.
     */
	public DiffEngine(String testOutputDirectory, 
			List<String> derbyOutputFilter, List<String> spliceOutputFilter) {
		this.testOutputDir = testOutputDirectory;
		this.derbyFilter = derbyOutputFilter;
		this.spliceFilter = spliceOutputFilter;
	}

	/**
     * Calculate the differences of the output generated by all the given SQL scripts.
     * @param sqlFiles SQL script files that were executed against Derby and Splice
     *                 to produce output residing in <code>testOutputDir</code>
     * @return the list of {@link VerifyReport}s
     * @throws FileNotFoundException if <code>sqlFiles</code> or results
     * cannot be found.
     */
    @Override
    public List<VerifyReport> verifyOutput(List<File> sqlFiles) throws FileNotFoundException {
    	// test for diff output
    	verifyExists(testOutputDir, TestUtils.DERBY_OUTPUT_EXT);
    	verifyExists(testOutputDir, TestUtils.SPLICE_OUTPUT_EXT);

        List<VerifyReport> diffs = new ArrayList<VerifyReport>();

        for (File sqlFile: sqlFiles) {
            // derby output
            String derbyFileName = testOutputDir + sqlFile.getName().replace(".sql", TestUtils.DERBY_OUTPUT_EXT);
            // NOTE: we need ALL lines, including "--" comments because
            // there are differencing directives in there
            List<String> derbyFileLines = TestUtils.fileToLines(derbyFileName, (String)null);
            // filter derby warnings, etc
            derbyFileLines = filterOutput(derbyFileLines, derbyFilter);

            // splice output
            String spliceFileName = testOutputDir + sqlFile.getName().replace(".sql", TestUtils.SPLICE_OUTPUT_EXT);
            // NOTE: we need ALL lines, including "--" comments because
            // there are differencing directives in there
            List<String> spliceFileLines = TestUtils.fileToLines(spliceFileName, (String)null);
            // filter splice warnings, etc
            spliceFileLines = filterOutput(spliceFileLines, spliceFilter);

            // Diff the output files using a custom Equalizer
            Patch<String> patch = DiffUtils.diff(derbyFileLines, spliceFileLines, new LineEqualizer());

            // Create a diff report for this SQL script output
            DiffReport diff = new DiffReport(derbyFileName, spliceFileName, patch.getDeltas());
            diffs.add(diff);
        }
        return diffs;
    }

	/**
     * Remove (filter) any lines in <code>fileLines</code> that contain any occurrences of
     * <code>lineFilters</code>
     * <p>
     *     This method is used to filter lines from one output file that are not in the
     *     other.  Lines in one file that ARE NOT in the other throw off diff comparison
     *     by one line.<br/>
     *     <b>NEVER</b> use this method to filter lines from one output file that are also
     *     in the other, unless you filter the same lines from the other.
     * </p>
     * @param fileLines the strings to consider
     * @param lineFilters patterns, occurrences of which, should be filtered.
     * @return the result of the <code>fileLines</code> filtering (lines with lineFilters
     * removed).
     */
    public static List<String> filterOutput(List<String> fileLines, List<String> lineFilters) {
        if (isEmpty(fileLines) || isEmpty(lineFilters)) {
            return fileLines;
        }
        List<String> copy = Collections.synchronizedList(new ArrayList<String>(fileLines));
        List<String> filteredLines = Collections.synchronizedList(new ArrayList<String>(fileLines.size()));
        for (String line : copy) {
            boolean filter = false;

            for (String warning : lineFilters) {
                if (line.contains(warning)) {
                    filter = true;
                    break;
                }
            }
            if (! filter) {
                filteredLines.add(line);
            }
        }
        return filteredLines;
    }

    private static boolean isEmpty(Collection<? extends Object> objects) {
        return (objects == null || objects.isEmpty());
    }

    private static void verifyExists(String dir, String fileExt) throws FileNotFoundException {
    	String ext = fileExt;
    	if (ext.startsWith(".")) {
    		// trim starting '.' (dot) 
    		ext = ext.substring(1);
    	}
    	Collection<File> files = FileUtils.listFiles(new File(dir), new String[] {ext}, false);
    	if (files.isEmpty()) {
    		throw new FileNotFoundException("The directory ["+dir+"] contains no files with extension ["+fileExt+"]");
    	}
	}

}
