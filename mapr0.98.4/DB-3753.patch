diff --git a/pom.xml b/pom.xml
index 7068a26..d208b50 100644
--- a/pom.xml
+++ b/pom.xml
@@ -560,7 +560,7 @@
 				<module>hdp2.2.4</module>
 				<!--module>hdp2.3.0</module-->
 				<module>mapr0.98.4</module>
-				<!--module>mapr0.98.12</module-->
+				<module>mapr0.98.12</module>
 			</modules>
 		</profile>
 		<profile>
@@ -912,5 +912,11 @@
 				<module>mapr0.98.4</module>
 			</modules>
 		</profile>
+		<profile>
+			<id>mapr0.98.12</id>
+			<modules>
+				<module>mapr0.98.12</module>
+			</modules>
+		</profile>
 	</profiles>
 </project>
diff --git a/splice_constants/src/main/java/com/splicemachine/constants/SpliceConstants.java b/splice_constants/src/main/java/com/splicemachine/constants/SpliceConstants.java
index fd9c076..4964b82 100644
--- a/splice_constants/src/main/java/com/splicemachine/constants/SpliceConstants.java
+++ b/splice_constants/src/main/java/com/splicemachine/constants/SpliceConstants.java
@@ -666,40 +666,6 @@ public class SpliceConstants {
     public static long optimizerTableMinimalRows;
 
     /**
-     * Minimum fixed duration (in millisecomds) that should be allowed to lapse
-     * before the optimizer can determine that it should stop trying to find
-     * the best plan due to plan time taking longer than the expected
-     * query execution time. By default, this is zero, which means
-     * there is no fixed minimum, and the determination is made
-     * using cost estimates alone. Default value should generally
-     * be left alone, and would only need to be changed as a workaround
-     * for inaccurate cost estimates.
-     * 
-     * @return minimum plan timeout regardless of cost based time limit
-     */
-    @Parameter private static final String OPTIMIZER_PLAN_MINIMUM_TIMEOUT = "splice.optimizer.minPlanTimeout";
-    @DefaultValue(OPTIMIZER_PLAN_MINIMUM_TIMEOUT) public static final long DEFAULT_OPTIMIZER_PLAN_MINIMUM_TIMEOUT = 0L;
-    // Only used by the method OptimizerImpl.checkTimeout()
-    public static long optimizerPlanMinimumTimeout;
-    
-    /**
-     * Maximum fixed duration (in millisecomds) that should be allowed to lapse
-     * before the optimizer can determine that it should stop trying to find
-     * the best plan due to plan time taking longer than the expected
-     * query execution time. By default, this is {@link Long.MAX_VALUE}, which means
-     * there is no fixed maximum, and the determination is made
-     * using cost estimates alone. Default value should generally
-     * be left alone, and would only need to be changed as a workaround
-     * for inaccurate cost estimates.
-     * 
-     * @return maximum plan timeout regardless of cost based time limit
-     */
-    @Parameter private static final String OPTIMIZER_PLAN_MAXIMUM_TIMEOUT = "splice.optimizer.maxPlanTimeout";
-    @DefaultValue(OPTIMIZER_PLAN_MAXIMUM_TIMEOUT) public static final long DEFAULT_OPTIMIZER_PLAN_MAXIMUM_TIMEOUT = Long.MAX_VALUE;
-    // Only used by the method OptimizerImpl.checkTimeout()
-    public static long optimizerPlanMaximumTimeout;
-    
-    /**
      * The length of time (in seconds) to wait before killing a write thread which is not in use. Turning
      * this up will result in more threads being available for writes after longer periods of inactivity,
      * but will cause higher thread counts in the system overall. Turning this down will result in fewer
@@ -1166,9 +1132,6 @@ public class SpliceConstants {
         getBaseTableFetchFromFullKeyCost = SpliceConstants.config.getFloat(GET_BASE_TABLE_FETCH_FROM_FULL_KEY_COST, (float) DEFAULT_GET_BASE_TABLE_FETCH_FROM_FULL_KEY_COST);
         getIndexFetchFromFullKeyCost = SpliceConstants.config.getFloat(GET_INDEX_FETCH_FROM_FULL_KEY_COST, (float) DEFAULT_GET_INDEX_FETCH_FROM_FULL_KEY_COST);
         optimizerTableMinimalRows = SpliceConstants.config.getLong(OPTIMIZER_TABLE_MINIMAL_ROWS, DEFAULT_OPTIMIZER_TABLE_MINIMAL_ROWS);
-        optimizerPlanMinimumTimeout = SpliceConstants.config.getLong(OPTIMIZER_PLAN_MINIMUM_TIMEOUT, DEFAULT_OPTIMIZER_PLAN_MINIMUM_TIMEOUT);
-        optimizerPlanMaximumTimeout = SpliceConstants.config.getLong(OPTIMIZER_PLAN_MAXIMUM_TIMEOUT, DEFAULT_OPTIMIZER_PLAN_MAXIMUM_TIMEOUT);
-        
         if(ipcThreads < maxThreads){
             /*
              * Some of our writes will also write out to indices and/or read data from HBase, which
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BaseCostedHashableJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BaseCostedHashableJoinStrategy.java
deleted file mode 100644
index e1ecc0b..0000000
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BaseCostedHashableJoinStrategy.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.splicemachine.derby.impl.sql.compile;
-
-import com.splicemachine.db.iapi.error.StandardException;
-import com.splicemachine.db.iapi.sql.compile.Optimizable;
-import com.splicemachine.db.iapi.sql.compile.OptimizablePredicateList;
-import com.splicemachine.db.iapi.sql.dictionary.ConglomerateDescriptor;
-import com.splicemachine.db.iapi.sql.dictionary.IndexRowGenerator;
-import com.splicemachine.db.iapi.store.access.StoreCostController;
-import com.splicemachine.db.impl.sql.compile.*;
-
-import java.util.BitSet;
-
-/**
- * Abstract class to provide convenience methods for costing joins.
- *
- * @author Scott Fines
- *         Date: 3/25/15
- */
-public abstract class BaseCostedHashableJoinStrategy extends HashableJoinStrategy{
-
-    protected double getTotalHeapSize(double outerHeapSize,
-                                        double innerHeapSize,
-                                        double innerRowCount,
-                                        double outerRowCount,
-                                        double totalOutputRows){
-        double perRowHeapSize = outerHeapSize/outerRowCount;
-        perRowHeapSize+=innerHeapSize/innerRowCount;
-        return perRowHeapSize*totalOutputRows;
-    }
-
-    protected double getTotalRemoteCost(double outerRemoteCost,
-                                        double innerRemoteCost,
-                                        double outerRowCount,
-                                        double innerRowCount,
-                                        double totalOutputRows){
-        double perRowRemoteCost = outerRemoteCost/outerRowCount;
-        perRowRemoteCost+=innerRemoteCost/innerRowCount;
-        return totalOutputRows*perRowRemoteCost;
-    }
-
-}
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BroadcastJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BroadcastJoinStrategy.java
index 8d9efd3..da6898a 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BroadcastJoinStrategy.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/BroadcastJoinStrategy.java
@@ -5,12 +5,9 @@ import com.splicemachine.db.iapi.error.StandardException;
 import com.splicemachine.db.iapi.sql.compile.*;
 import com.splicemachine.db.iapi.sql.dictionary.ConglomerateDescriptor;
 import com.splicemachine.db.iapi.sql.dictionary.TableDescriptor;
-import com.splicemachine.db.impl.sql.compile.FromBaseTable;
-import com.splicemachine.db.impl.sql.compile.Predicate;
-import com.splicemachine.db.impl.sql.compile.PredicateList;
-import com.splicemachine.db.impl.sql.compile.SelectivityUtil;
+import com.splicemachine.db.impl.sql.compile.*;
 
-public class BroadcastJoinStrategy extends BaseCostedHashableJoinStrategy {
+public class BroadcastJoinStrategy extends HashableJoinStrategy {
     public BroadcastJoinStrategy() { }
 
     /**
@@ -135,49 +132,14 @@ public class BroadcastJoinStrategy extends BaseCostedHashableJoinStrategy {
             return; //actually a scan, don't do anything
         }
         innerCost.setBase(innerCost.cloneMe());
-        double outerRowCount=outerCost.rowCount();
-        double innerRowCount=innerCost.rowCount();
-        if(innerRowCount==0d){
-            //we don't do anything to the base scan costs, but we DO affect the join
-            //selectivity, so we treat the inner row count as 1
-            innerRowCount = 1d;
-        }
-        if(outerRowCount==0d){
-            outerRowCount = 1d;
-        }
-
-        double outerRemoteCost=outerCost.remoteCost();
-        double innerRemoteCost=innerCost.remoteCost();
-
-        double joinSelectivity = SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList, (long) innerRowCount, (long) outerRowCount, outerCost);
-
-        double totalLocalCost = outerCost.localCost()+innerCost.localCost()+innerRemoteCost;
-        //add in the overhead to open the inner table scan
-        totalLocalCost+= innerCost.partitionCount()*(innerCost.getOpenCost()+innerCost.getCloseCost());
-
-
-        double totalOutputRows = joinSelectivity*outerRowCount*innerRowCount;
-
-        double totalRemoteCost=getTotalRemoteCost(outerRemoteCost,innerRemoteCost,outerRowCount,innerRowCount,totalOutputRows);
-
-        //each partition of the outer table will see inner table's partitionCount
-        int totalPartitionCount = outerCost.partitionCount();
-
-        double totalHeapSize=getTotalHeapSize(outerCost.getEstimatedHeapSize(),
-                innerCost.getEstimatedHeapSize(),
-                innerRowCount,
-                outerRowCount,
-                totalOutputRows);
-
-        innerCost.setNumPartitions(totalPartitionCount);
-        innerCost.setLocalCost(totalLocalCost);
-        innerCost.setRemoteCost(totalRemoteCost);
-//        innerCost.setRowOrdering(null);
+        double joinSelectivity = SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList, (long) innerCost.rowCount(), (long) outerCost.rowCount(), outerCost);
+        double totalOutputRows = SelectivityUtil.getTotalRows(joinSelectivity,outerCost.rowCount(),innerCost.rowCount());
+        innerCost.setNumPartitions(outerCost.partitionCount());
+        innerCost.setLocalCost(SelectivityUtil.broadcastJoinStrategyLocalCost(innerCost,outerCost));
+        innerCost.setRemoteCost(SelectivityUtil.getTotalRemoteCost(innerCost,outerCost,totalOutputRows));
         innerCost.setRowOrdering(outerCost.getRowOrdering());
         innerCost.setRowCount(totalOutputRows);
-        innerCost.setEstimatedHeapSize((long)totalHeapSize);
-//        innerCost.setSingleScanRowCount(innerCost.rowCount());
-//        innerCost.setSingleScanRowCount(joinSelectivity*outerCost.singleScanRowCount());
+        innerCost.setEstimatedHeapSize((long)SelectivityUtil.getTotalHeapSize(innerCost,outerCost,totalOutputRows));
     }
 
     @Override
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HashNestedLoopJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HashNestedLoopJoinStrategy.java
deleted file mode 100644
index 1af9292..0000000
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HashNestedLoopJoinStrategy.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package com.splicemachine.derby.impl.sql.compile;
-
-import com.splicemachine.db.iapi.error.StandardException;
-import com.splicemachine.db.iapi.services.sanity.SanityManager;
-import com.splicemachine.db.iapi.sql.compile.CostEstimate;
-import com.splicemachine.db.iapi.sql.compile.JoinStrategy;
-import com.splicemachine.db.iapi.sql.compile.Optimizable;
-import com.splicemachine.db.iapi.sql.compile.OptimizablePredicate;
-import com.splicemachine.db.iapi.sql.compile.OptimizablePredicateList;
-import com.splicemachine.db.iapi.sql.compile.Optimizer;
-import com.splicemachine.db.iapi.sql.dictionary.ConglomerateDescriptor;
-import com.splicemachine.db.iapi.sql.dictionary.DataDictionary;
-import com.splicemachine.db.impl.sql.compile.FromBaseTable;
-import com.splicemachine.db.impl.sql.compile.HashableJoinStrategy;
-import org.apache.log4j.Logger;
-
-import com.splicemachine.constants.SpliceConstants;
-import com.splicemachine.utils.SpliceLogUtils;
-
-/**
- * @author Scott Fines
- *         Date: 7/24/14
- */
-public class HashNestedLoopJoinStrategy extends HashableJoinStrategy {
-    private static final Logger LOG = Logger.getLogger(HashNestedLoopJoinStrategy.class);
-    @Override
-    public String getName() {
-        return "HASH";
-    }
-
-    @Override
-    public String toString(){
-        return "Hash";
-    }
-
-    @Override
-    public String resultSetMethodName(boolean bulkFetch, boolean multiprobe) {
-        if (bulkFetch)
-            return "getBulkTableScanResultSet";
-        else if (multiprobe)
-            return "getMultiProbeTableScanResultSet";
-        else
-            return "getTableScanResultSet";
-    }
-
-    @Override
-    public String joinResultSetMethodName() {
-        return "getHashJoinResultSet";
-    }
-
-    @Override
-    public String halfOuterJoinResultSetMethodName() {
-        return "getHashLeftOuterJoinResultSet";
-    }
-    
- 
-
-    /** @see com.splicemachine.db.iapi.sql.compile.JoinStrategy#nonBasePredicateSelectivity */
-    public double nonBasePredicateSelectivity(Optimizable innerTable,OptimizablePredicateList predList) throws StandardException {
-        double retval = 1.0;
-        if (predList != null) {
-            for (int i = 0; i < predList.size(); i++) {
-                // Don't include redundant join predicates in selectivity calculations
-                if (predList.isRedundantPredicate(i)) {
-                    continue;
-                }
-                retval *= predList.getOptPredicate(i).selectivity(innerTable);
-            }
-        }
-        return retval;
-    }
-
-    /**
-     * @see com.splicemachine.db.iapi.sql.compile.JoinStrategy#putBasePredicates
-     *
-     * @exception StandardException		Thrown on error
-     */
-    public void putBasePredicates(OptimizablePredicateList predList,OptimizablePredicateList basePredicates) throws StandardException {
-        for (int i = basePredicates.size() - 1; i >= 0; i--) {
-            OptimizablePredicate pred = basePredicates.getOptPredicate(i);
-            predList.addOptPredicate(pred);
-            basePredicates.removeOptPredicate(i);
-        }
-    }
-    
-    @Override
-    public boolean isHashJoin() {
-        return false;
-    }
-
-    @Override
-    public boolean feasible(Optimizable innerTable,
-                            OptimizablePredicateList predList,
-                            Optimizer optimizer,
-                            CostEstimate outerCost,
-                            boolean wasHinted) throws StandardException {
-//		if (CostUtils.isThisBaseTable(optimizer))
-//			return false;
-    	SpliceLogUtils.trace(LOG, "feasible innerTable=%s, predList=%s, optimizer=%s",innerTable,predList,optimizer);
-    	return false;  // Temprorary until we can reason about this join algorithm
-    	
-        /*
-         * Somewhat Temporary Fix.
-         *
-         * The HashNestedLoopJoinStrategy doesn't make a whole lot of sense unless it is used over
-         * a raw table scan or index lookup (e.g. doing it over a sink operation isn't very useful). Additionally,
-         * in that case the raw NestedLoopJoin or MergeSortJoin are both more preferable operations than this anyway.
-         * Thus, we just make this plan infeasible if there is a sink node under this tree. In addition to
-         * this, we also don't want to use MultiProbe scans under this instance--better to use Raw NLJ or MergeSort
-         * to make those work.
-         */
-    	// Could Check for Sortability here?
-        /*
-    	boolean hashableFeasible = super.feasible(innerTable,predList,optimizer);
-    	boolean isOneRowResultSet = false;
-    	if (innerTable instanceof FromBaseTable)
-    		isOneRowResultSet = ((FromBaseTable) innerTable).isOneRowResultSet(predList);
-    	SpliceLogUtils.trace(LOG, "feasible? hashableFeasible=%s, isOneRowResultSet=%s",hashableFeasible,isOneRowResultSet);    	
-    	return hashableFeasible && isOneRowResultSet;   
-    	*/
-    }
-
-
-    ;
-
-	/**
-	 * 
-	 * Right Side Cost + Network Cost + RightSideRows*Hash Cost 
-	 * 
-	 */
-	@Override
-	public void estimateCost(Optimizable innerTable,
-                             OptimizablePredicateList predList,
-                             ConglomerateDescriptor cd,
-                             CostEstimate outerCost,
-                             Optimizer optimizer,
-                             CostEstimate innerCost) {
-		SpliceLogUtils.trace(LOG, "rightResultSetCostEstimate outerCost=%s, innerFullKeyCost=%s",outerCost, innerCost);
-		double cost;
-//		if (outerCost.getEstimatedRowCount() > 10000)
-//			cost = Double.MAX_VALUE;
-//		else 
-	    if (outerCost.getEstimatedRowCount() > SpliceConstants.hashNLJRightHashTableSize)
-			cost = (SpliceConstants.optimizerNetworkCost/(double)SpliceConstants.hashNLJRightHashTableSize+innerCost.getEstimatedCost()+SpliceConstants.optimizerHashCost)* outerCost.getEstimatedRowCount();
-		else
-			cost = SpliceConstants.optimizerNetworkCost + (innerCost.getEstimatedCost()+SpliceConstants.optimizerHashCost)* outerCost.getEstimatedRowCount();
-		innerCost.setCost(cost, innerCost.rowCount() * outerCost.rowCount(), innerCost.singleScanRowCount());
-		SpliceLogUtils.trace(LOG, "rightResultSetCostEstimate computed cost innerCost=%s",innerCost);
-	};	
-	public boolean singleRowOnly() {
-		return true;
-	}
-
-	@Override
-	public void divideUpPredicateLists(Optimizable innerTable,
-			OptimizablePredicateList originalRestrictionList,
-			OptimizablePredicateList storeRestrictionList,
-			OptimizablePredicateList nonStoreRestrictionList,
-			OptimizablePredicateList requalificationRestrictionList,
-			DataDictionary dd) throws StandardException {
-				originalRestrictionList.setPredicatesAndProperties(storeRestrictionList);
-	};
-
-    @Override
-    public JoinStrategyType getJoinStrategyType() {
-        return JoinStrategyType.NESTED_LOOP;
-    }
-
-}
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java
index 4883a94..12647b0 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java
@@ -8,7 +8,7 @@ import com.splicemachine.db.impl.sql.compile.*;
 import java.util.Arrays;
 import java.util.BitSet;
 
-public class MergeJoinStrategy extends BaseCostedHashableJoinStrategy{
+public class MergeJoinStrategy extends HashableJoinStrategy{
 
     public MergeJoinStrategy(){
     }
@@ -103,83 +103,16 @@ public class MergeJoinStrategy extends BaseCostedHashableJoinStrategy{
         }
         //preserve the underlying CostEstimate for the inner table
         innerCost.setBase(innerCost.cloneMe());
+        double joinSelectivity = SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList, (long) innerCost.rowCount(), (long) outerCost.rowCount(), outerCost);
+        double totalOutputRows = SelectivityUtil.getTotalRows(joinSelectivity,outerCost.rowCount(),innerCost.rowCount());
+        innerCost.setNumPartitions(outerCost.partitionCount());
+        innerCost.setLocalCost(SelectivityUtil.mergeJoinStrategyLocalCost(innerCost,outerCost));
+        innerCost.setRemoteCost(SelectivityUtil.getTotalRemoteCost(innerCost,outerCost,totalOutputRows));
+        innerCost.setRowOrdering(outerCost.getRowOrdering());
+        innerCost.setRowCount(totalOutputRows);
+        innerCost.setEstimatedHeapSize((long)SelectivityUtil.getTotalHeapSize(innerCost,outerCost,totalOutputRows));
 
-        /*
-         * The Merge Join algorithm is quite simple--for each outer row, we read rows until
-         * either A) we reach a row which matches the join predicates, or B) we reach a row
-         * which is past the join predicates. In all cases, we read the outer table fully,
-         * and we read the inner row equally fully (although we terminate early once we exceed the
-         * other table scan's stop key, and we start the inner table scan at the correct point
-         * for the first outer row). As a result, we know that we touch each inner row exactly once,
-         * and we touch each outer row exactly once. Therefore, we have an additive cost as follows:
-         *
-         * totalLocalCost = outer.localCost+inner.localCost+inner.remoteCost
-         * totalRemoteCost = outer.remoteCost + inner.remoteCost
-         *
-         * Which includes network traffic to the outer table's region and network traffic from
-         * that region to the control node
-         */
-        double outerRowCount=outerCost.rowCount();
-        double innerRowCount=innerCost.rowCount();
-        if(outerRowCount==0){
-            /*
-             * There is no way that merge will do anything, so we can just stop here
-             */
-            return;
-        }
-        if(innerRowCount==0){
-            /*
-             * We don't modify the scan any, but it's possible that the inner side
-             * has non-negligible costs in order to generate 0 rows, so we can't disregard it.
-             * Instead, we just assume that innerRowCount==1
-             */
-            innerRowCount = 1d;
-        }
-        double joinSelectivity =SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList,(long) innerRowCount,(long) outerRowCount, outerCost);
-
-        double outerRemoteCost=outerCost.remoteCost();
-
-        double rowCount = joinSelectivity*outerRowCount*innerRowCount;
-
-        double innerRemoteCost=innerCost.remoteCost();
-        double totalLocalCost = outerCost.localCost()+innerCost.localCost()+innerRemoteCost;
-        totalLocalCost+=innerCost.partitionCount()*(innerCost.getOpenCost()+innerCost.getCloseCost());
-
-        /*
-         * The costing for broadcast and merge joins are essentially identical, so
-         * it's possible (particularly in the event of high-selectivity joins)
-         * that merge and broadcast joins will cost identicaly. In these situations, we want to
-         * favor merge join, since it can start late and stop early, and thus shave off a few
-         * microseconds of latency. We do this by downshifting the remote cost by a very small
-         * factor (just 5). That way, the costing strategies are slightly different, and we
-         * can favor merge join when all other things are equal
-         */
-        double totalRemoteCost = getTotalRemoteCost(outerRemoteCost,
-                innerRemoteCost,
-                outerRowCount,
-                innerRowCount,
-                rowCount)-5;
-        double heapSize = getTotalHeapSize(outerCost.getEstimatedHeapSize(),
-                innerCost.getEstimatedHeapSize(),
-                innerRowCount,
-                outerRowCount,
-                rowCount);
-        int numPartitions = outerCost.partitionCount()*innerCost.partitionCount();
-
-        /*
-         * MergeJoin is sorted according to the outer table first, then the inner table
-         */
-        RowOrdering outerRowOrdering = outerCost.getRowOrdering();
-        RowOrdering innerRowOrdering = innerCost.getRowOrdering();
-        RowOrdering outputOrder = outerRowOrdering.getClone();
-        innerRowOrdering.copy(outputOrder);
 
-        innerCost.setRowOrdering(outputOrder);
-        innerCost.setLocalCost(totalLocalCost);
-        innerCost.setRemoteCost(totalRemoteCost);
-        innerCost.setRowCount(rowCount);
-        innerCost.setEstimatedHeapSize((long)heapSize);
-        innerCost.setNumPartitions(numPartitions);
     }
 
     /* ****************************************************************************************************************/
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeSortJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeSortJoinStrategy.java
index 5e81ab6..abcb3e6 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeSortJoinStrategy.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeSortJoinStrategy.java
@@ -3,10 +3,10 @@ package com.splicemachine.derby.impl.sql.compile;
 import com.splicemachine.db.iapi.error.StandardException;
 import com.splicemachine.db.iapi.sql.compile.*;
 import com.splicemachine.db.iapi.sql.dictionary.ConglomerateDescriptor;
-import com.splicemachine.db.impl.sql.compile.FromBaseTable;
+import com.splicemachine.db.impl.sql.compile.HashableJoinStrategy;
 import com.splicemachine.db.impl.sql.compile.SelectivityUtil;
 
-public class MergeSortJoinStrategy extends BaseCostedHashableJoinStrategy {
+public class MergeSortJoinStrategy extends HashableJoinStrategy {
 
     public MergeSortJoinStrategy() {
     }
@@ -16,8 +16,6 @@ public class MergeSortJoinStrategy extends BaseCostedHashableJoinStrategy {
                             OptimizablePredicateList predList,
                             Optimizer optimizer,
                             CostEstimate outerCost,boolean wasHinted) throws StandardException {
-//		if (CostUtils.isThisBaseTable(optimizer))
-//			return false;
 		return super.feasible(innerTable, predList, optimizer,outerCost,wasHinted);
 	}
 
@@ -80,135 +78,20 @@ public class MergeSortJoinStrategy extends BaseCostedHashableJoinStrategy {
                 outerCost.setRowOrdering(ro); //force a cloning
             return; //actually a scan, don't change the cost
         }
-
         //set the base costing so that we don't lose the underlying table costs
         innerCost.setBase(innerCost.cloneMe());
-        /*
-         * MergeSortJoins are complex, and likely to change. We break this up
-         * into two different versions: a "TempTable" version, and a "Spark version".
-         * Currently, the "Spark version" is unimplemented, but when this merges
-         * in we'll need to re-cost that
-         */
-        tempTableCost(innerTable,predList,cd,outerCost,optimizer,innerCost);
-	}
-
-    private void tempTableCost(Optimizable innerTable,
-                               OptimizablePredicateList predList,
-                               ConglomerateDescriptor cd,
-                               CostEstimate outerCost,
-                               Optimizer optimizer,
-                               CostEstimate innerCost) throws StandardException{
-        /*
-         * Using the TEMP table algorithm, MergeSort Joins have a complicated
-         * algorithmic structure(and therefore, a complicated cost structure).
-         *
-         * There are two phases to the merge sort join: the "sort" and the "merge"
-         * phases. The Sort phase *must* occur completely before the Merge phase
-         * can begin (in the TEMP-based algorithm). Because of this, we
-         * cost the two phases independently, and add them together at the end
-         *
-         * ------
-         * Sort Phase costing:
-         *
-         * The sort phase is a parallel writing algorithm which concurrently reads
-         * the inner and outer tables and writes their output into 16 TEMP blocks.
-         * The cost to read and move the outer table is
-         *
-         * outerTableSortCost = outerTable.localCost+outerTable.remoteCost
-         *
-         * (Note that we assume the cost to write data is the same as the cost
-         * to read data, which is probably not entirely true--still, it's convenient
-         * for now)
-         *
-         * And the cost to read and move the inner table is
-         *
-         * innerTableSortCost = innerTable.localCost + innerTable.remoteCost
-         *
-         * Since both the inner and outer tables are being read and moved concurrently,
-         * we note that
-         *
-         * sortLocalCost    = max(outerTableSortCost,innerTableSortCost)
-         * sortRemoteCost   = sortLocalCost
-         * sortOutputRows   = outerTable.rowCount +innerTable.rowCount
-         * sortHeapSize     = outerTable.heapSize + innerTable.heapSize
-         * sortPartitions   = outerTable.partitions+innerTable.partitions
-         *
-         * -------
-         * Merge Phase costing:
-         *
-         * The merge phase consists of reading all data stored in
-         * the sorted partitions, and generating merged rows. Fundamentally,
-         * we don't know the latency to read data from TEMP(this is something for the
-         * future),so we approximate it by
-         *
-         * L = outerTable.localCost/2*outerTable.rowCount
-         *          +innerTable.localCost/2*innerTable.rowCount
-         *
-         * Which allows us to compute the merge costing as
-         *
-         * mergeLocalCost = L*(outerTable.numRows+innerTable.numRows)
-         * mergeRemoteCost = joinSelectivity*(outerTable.numRows*innerTable.numRows)
-         * mergeHeapSize = joinSelectivity*(outerTable.heapSize*innerTable.heapSize)
-         * mergePartitions = 16(or whatever the size of TEMP is currently)
-         */
-        double innerRowCount=innerCost.rowCount();
-        double outerRowCount=outerCost.rowCount();
-        if(innerRowCount==0d){
-            if(outerRowCount==0d) return; //we don't expect to change the cost any when we run this, because we expect to be empty
-            else{
-                /*
-                 * For the purposes of estimation, we will assume that the innerRowCount = 1, so that
-                 * we can safely compute the estimate. The difference between 1 and 0 is generally negliable,
-                 * and it will allow us to get a sensical cost estimate
-                 */
-                innerRowCount = 1d;
-            }
-        }else if(outerRowCount==0d){
-            /*
-             * For the purposes of safe estimation, we assume that we are returning at least one row. The
-             * cost difference is relatively negligiable, but this way we avoid NaNs and so forth.
-             */
-            outerRowCount = 1d;
-        }
-
-        double outerRemoteCost=outerCost.remoteCost();
-        double innerRemoteCost=innerCost.remoteCost();
-
-        double outerSortCost = (outerCost.localCost()+outerRemoteCost)/outerCost.partitionCount();
-        double innerSortCost = (innerCost.localCost()+innerRemoteCost)/innerCost.partitionCount();
-        double sortCost = Math.max(outerSortCost,innerSortCost);
 
-        double perRowLocalLatency = outerCost.localCost()/(2*outerRowCount);
-        perRowLocalLatency+=innerCost.localCost()/(2*innerRowCount);
-
-        double joinSelectivity = SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList, (long) innerRowCount, (long) outerRowCount, outerCost);
-
-
-        double mergeRows = joinSelectivity*(outerRowCount*innerRowCount);
-        int mergePartitions = (int)Math.round(Math.min(16,mergeRows));
-        double mergeLocalCost = perRowLocalLatency*(outerRowCount+innerRowCount);
-        double avgOpenCost = (outerCost.getOpenCost()+innerCost.getOpenCost())/2;
-        double avgCloseCost = (outerCost.getCloseCost()+innerCost.getCloseCost())/2;
-        mergeLocalCost+=mergePartitions*(avgOpenCost+avgCloseCost);
-        double mergeRemoteCost = getTotalRemoteCost(outerRemoteCost,innerRemoteCost,outerRowCount,innerRowCount,mergeRows);
-        double mergeHeapSize = getTotalHeapSize(outerCost.getEstimatedHeapSize(),
-                innerCost.getEstimatedHeapSize(),
-                innerRowCount,
-                outerRowCount,
-                mergeRows);
-
-        double totalLocalCost = sortCost+mergeLocalCost;
-
-        innerCost.setRemoteCost(mergeRemoteCost);
-        innerCost.setLocalCost(totalLocalCost);
-        innerCost.setRowCount(mergeRows);
-        innerCost.setEstimatedHeapSize((long)mergeHeapSize);
-        innerCost.setNumPartitions(mergePartitions);
-        /*
-         * The TEMP algorithm re-sorts data according to join keys, which eliminates the sort order
-         * of the data.
-         */
+        innerCost.setBase(innerCost.cloneMe());
+        double joinSelectivity = SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList, (long) innerCost.rowCount(), (long) outerCost.rowCount(), outerCost);
+        double totalOutputRows = SelectivityUtil.getTotalRows(joinSelectivity,outerCost.rowCount(),innerCost.rowCount());
+        innerCost.setNumPartitions(outerCost.partitionCount());
+        innerCost.setLocalCost(SelectivityUtil.mergeSortJoinStrategyLocalCost(innerCost,outerCost,3));
+        innerCost.setRemoteCost(SelectivityUtil.getTotalRemoteCost(innerCost,outerCost,totalOutputRows));
+        innerCost.setRowOrdering(outerCost.getRowOrdering());
+        innerCost.setRowCount(totalOutputRows);
+        innerCost.setEstimatedHeapSize((long)SelectivityUtil.getTotalHeapSize(innerCost,outerCost,totalOutputRows));
         innerCost.setRowOrdering(null);
+        innerCost.setNumPartitions(16);
     }
 
     @Override
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/NestedLoopJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/NestedLoopJoinStrategy.java
index 6d04b75..3075422 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/NestedLoopJoinStrategy.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/NestedLoopJoinStrategy.java
@@ -213,8 +213,6 @@ public class NestedLoopJoinStrategy extends BaseJoinStrategy{
         return false;
     }
 
-    @Override public boolean allowsJoinPredicatePushdown(){ return true; }
-
     @Override
     public String toString(){
         return "NestedLoopJoin";
@@ -242,107 +240,13 @@ public class NestedLoopJoinStrategy extends BaseJoinStrategy{
         }
         //set the base costs for the join
         innerCost.setBase(innerCost.cloneMe());
-//        outerCost.setBase(outerCost.cloneMe());
-
-        /*
-         * NestedLoopJoins are very simple. For each outer row, we create a new scan of the inner
-         * table, looking for rows which match the join predicates. Therefore, for each outer row,
-         * we must pay the local penalty of
-         *
-         * innerCost.localCost
-         *
-         * and the remote penalty of
-         *
-         * innerCost.remoteCost * (number of rows matching join predicates)
-         *
-         * the number of rows matching the join predicate is the "join selectivity", so a better formulation is:
-         *
-         * innerScan.outputRows = joinSelectivity*innerCost.outputRows
-         * innerScan.localCost = innerCost.localCost
-         * innerScan.remoteCost = innerCost.remoteCost*innerCost.outputRows
-         * innerScan.heapSize = innerCost.heapSize*joinSelectivity
-         *
-         * Note,however, that some join predicates may be start and stop predicates, which will reduce
-         * the number of rows we have to touch during the inner scan. As a result, we have to keep
-         * 2 selectivities: the "output join selectivity" and the "input join selectivity". This adjusts the formulas
-         * to be:
-         *
-         * innerScan.outputRows = outputJoinSelectivity*innerCost.outputRows
-         * innerScan.localCost = inputJoinSelectivity*innerCost.localCost
-         * innerScan.remoteCost = outputJoinSelectivity*innerCost.remoteCost
-         * innerScan.heapSize = outputJoinSelectivity*innerCost.heapSize
-         *
-         * This the cost made *per outer row*, so our overall cost formula is:
-         *
-         * totalCost.localCost = outerCost.localCost + outerCost.outputRows*(innerScan.localCost+innerScan.remoteCost)
-         * totalCost.remoteCost = outerCost.remoteCost + outerCost.outputRows*(innerScan.remoteCost)
-         * totalCost.outputRows = outerCost.outputRows
-         * totalCost.heapSize = outerCost.heapSize
-         * totalCost.numPartitions = outerCost.numPartitions + innerCost.numPartitions
-         *
-         * Note that we add in the remote cost of the inner scan twice. This accounts for the fact that we have
-         * to read the innerScan's rows over the network twice--once to pull them to the outer table's region,
-         * and again to write that data across the network.
-         */
-
-        /*
-         * If the row count is 1l, then we are either a keyed lookup (a special case handled
-         * in FromBaseTable directly), or we are on a table with exactly 1 row returned (which is wild).
-         *
-         * If we are the latter, then not adjusting for start and stop key selectivity won't matter,
-         * and if we are the former, it'll screw up our costing model. So in both cases, don't
-         * adjust the selectivity if our estimated row count is 1
-         */
-
-        /*
-         * if the outer table claims to have no rows return, then
-         * we are in a bit of a dilemma. On the one hand, maybe nothing
-         * comes back, in which case that's correct. Or maybe there are no
-         * statistics, and we are just screwed anyway.
-         *
-         * Regardless, we don't want to mess up our own statistics by dividing by
-         * zero here and so forth, so we choose to accept some error for very small
-         * tables by resetting the output row count to 1 if it's less than that already.
-         */
-        double outerRowCount = outerCost.rowCount();
-        if(outerRowCount<1) outerRowCount=1d;
-
-        double innerScanLocalCost = innerCost.localCost();
-        double innerScanRemoteCost = innerCost.remoteCost();
-        double innerScanHeapSize = innerCost.getEstimatedHeapSize();
-        double innerScanOutputRows = innerCost.rowCount();
-        double joinSelectivity =SelectivityUtil.estimateJoinSelectivity(innerTable, cd, predList,(long) innerScanOutputRows,(long) outerRowCount, outerCost);
-
-        if(innerCost.getEstimatedRowCount()!=1l){
-            innerScanRemoteCost *= joinSelectivity;
-            innerScanHeapSize *= joinSelectivity;
-            innerScanOutputRows*=joinSelectivity;
-        }
-        double perOuterRowInnerCost = innerScanLocalCost+innerScanRemoteCost;
-        perOuterRowInnerCost+=innerCost.partitionCount()*(innerCost.getOpenCost()+innerCost.getCloseCost());
-
-        double totalLocalCost=outerCost.localCost()+outerCost.rowCount()*perOuterRowInnerCost;
-        int totalPartitions=outerCost.partitionCount();
-
-        /*
-         * unlike other join strategies, NLJ's row count selectivity is determined entirely by
-         * the predicates which are pushed to the right hand side. Therefore, the totalOutputRows
-         * is actually outerCost.rowCount()*innerScanOutputRows
-         */
-        double totalOutputRows=joinSelectivity*(outerCost.rowCount()*innerCost.rowCount());
-        double totalHeapSize=outerCost.getEstimatedHeapSize()+outerCost.rowCount()*innerScanHeapSize;
-
-        double perRowRemoteCost = outerCost.remoteCost()/outerRowCount;
-        if(innerScanOutputRows>0){
-            perRowRemoteCost+=innerCost.remoteCost()/innerCost.rowCount();
-        }
-        double totalRemoteCost=totalOutputRows*perRowRemoteCost;
+        double totalRowCount = outerCost.rowCount()*innerCost.rowCount();
 
-        innerCost.setEstimatedHeapSize((long)totalHeapSize);
-        innerCost.setNumPartitions(totalPartitions);
-        innerCost.setRowCount(totalOutputRows);
-        innerCost.setRemoteCost(totalRemoteCost);
-        innerCost.setLocalCost(totalLocalCost);
+        innerCost.setEstimatedHeapSize((long)SelectivityUtil.getTotalHeapSize(innerCost,outerCost,totalRowCount));
+        innerCost.setNumPartitions(outerCost.partitionCount());
+        innerCost.setRowCount(totalRowCount);
+        innerCost.setRemoteCost(SelectivityUtil.getTotalRemoteCost(innerCost,outerCost,totalRowCount));
+        innerCost.setLocalCost(SelectivityUtil.nestedLoopJoinStrategyLocalCost(innerCost,outerCost));
         innerCost.setRowOrdering(outerCost.getRowOrdering());
         innerCost.setSingleScanRowCount(innerCost.getEstimatedRowCount());
     }
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerFactoryImpl.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerFactoryImpl.java
index 7b7ba98..db931bd 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerFactoryImpl.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerFactoryImpl.java
@@ -47,12 +47,11 @@ public class SpliceLevel2OptimizerFactoryImpl extends OptimizerFactoryImpl {
 	* where users get different arrays.
 	*/
 		if (joinStrategySet == null) { // Do not change order...
-			JoinStrategy[] jss = new JoinStrategy[5];
+			JoinStrategy[] jss = new JoinStrategy[4];
 			jss[0] = new NestedLoopJoinStrategy();
 			jss[1] = new MergeSortJoinStrategy();
 			jss[2] = new BroadcastJoinStrategy();
 			jss[3] = new MergeJoinStrategy();
-			jss[4] = new HashNestedLoopJoinStrategy();
 			joinStrategySet = jss;
 		}
 
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerImpl.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerImpl.java
index ba3550b..ddf6fcf 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerImpl.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/SpliceLevel2OptimizerImpl.java
@@ -1,6 +1,5 @@
 package com.splicemachine.derby.impl.sql.compile;
 
-import com.splicemachine.constants.SpliceConstants;
 import com.splicemachine.db.iapi.error.StandardException;
 import com.splicemachine.db.iapi.sql.compile.*;
 import com.splicemachine.db.iapi.sql.conn.LanguageConnectionContext;
@@ -12,7 +11,6 @@ import com.splicemachine.derby.impl.stats.StatisticsStorage;
 import com.splicemachine.derby.impl.store.access.TempGroupedAggregateCostController;
 import com.splicemachine.derby.impl.store.access.TempScalarAggregateCostController;
 import com.splicemachine.derby.impl.store.access.TempSortController;
-
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
 import org.apache.log4j.Priority;
@@ -193,18 +191,4 @@ public class SpliceLevel2OptimizerImpl extends Level2OptimizerImpl{
         }
         return super.tracer();
     }
-    
-    /**
-     * Overridden to check splice configuration.
-     */
-    protected long getMinTimeout() {
-    	return SpliceConstants.optimizerPlanMinimumTimeout; // milliseconds
-    }
-
-    /**
-     * Overridden to check splice configuration.
-     */
-    protected long getMaxTimeout() {
-    	return SpliceConstants.optimizerPlanMaximumTimeout; // milliseconds
-    }
 }
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/distinctscalar/SingleDistinctScalarAggregateIterator.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/distinctscalar/SingleDistinctScalarAggregateIterator.java
index 480dfed..7bde87b 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/distinctscalar/SingleDistinctScalarAggregateIterator.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/distinctscalar/SingleDistinctScalarAggregateIterator.java
@@ -38,28 +38,19 @@ public class SingleDistinctScalarAggregateIterator extends AbstractStandardItera
 		}
 
 		public void merge(ExecRow newRow) throws StandardException{
-
-            for (SpliceGenericAggregator aggregator : aggregates) {
-
-                if (aggregator.isDistinct()) {
-                    if (currentValue == null) {
-                        if (currentRow != null) {
-                            currentValue = aggregator.getInputColumnValue(currentRow).cloneValue(false);
-                        }
+                if (currentValue == null) {
+                    if (currentRow != null) {
+                        currentValue = aggregates[0].getInputColumnValue(currentRow).cloneValue(false);
                     }
-
-                    DataValueDescriptor newValue = aggregator.getInputColumnValue(newRow);
-                    if (currentValue == null || currentValue.compare(newValue) != 0) {
-                        currentValue = newValue.cloneValue(false);
+                }
+                DataValueDescriptor newValue = aggregates[0].getInputColumnValue(newRow);
+                if (currentValue == null || currentValue.compare(newValue) != 0) {
+                    for (SpliceGenericAggregator aggregator : aggregates) {
+                        initialize(newRow);
+                        aggregator.merge(newRow, currentRow);
                     }
-                    else
-                        continue;
+                    currentValue = newValue.cloneValue(false);
                 }
-
-                initialize(newRow);
-                aggregator.merge(newRow, currentRow);
-            }
-
 		}
 
 		public void initialize(ExecRow newRow) throws StandardException{
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperation.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperation.java
index 4916176..4f67a1d 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperation.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperation.java
@@ -3,8 +3,6 @@ package com.splicemachine.derby.impl.sql.execute.operations.export;
 
 import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
-import com.splicemachine.db.iapi.reference.SQLState;
-import com.splicemachine.db.impl.sql.compile.ExportNode;
 import com.splicemachine.derby.hbase.SpliceObserverInstructions;
 import com.splicemachine.derby.iapi.sql.execute.*;
 import com.splicemachine.derby.iapi.storage.RowProvider;
@@ -67,11 +65,6 @@ public class ExportOperation extends SpliceBaseOperation implements SinkingOpera
                            String fieldSeparator,
                            String quoteCharacter) throws StandardException {
         super(activation, rsNumber, 0d, 0d);
-
-        if (replicationCount <= 0 && replicationCount != ExportNode.DEFAULT_INT_VALUE) {
-            throw StandardException.newException(SQLState.EXPORT_PARAMETER_IS_WRONG);
-        }
-
         this.source = source;
         this.sourceColumnDescriptors = sourceColumnDescriptors;
         this.exportParams = new ExportParams(exportPath, compression, replicationCount, encoding, fieldSeparator, quoteCharacter);
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/stats/IndexStatsCostController.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/stats/IndexStatsCostController.java
index a8f29e0..4a78bc1 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/stats/IndexStatsCostController.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/stats/IndexStatsCostController.java
@@ -69,4 +69,9 @@ public class IndexStatsCostController extends StatsStoreCostController {
         return baseTableStatistics.avgRowWidth();
     }
 
+    @Override
+    public double baseRowCount() {
+        return baseTableStatistics.rowCount();
+    }
+
 }
diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/store/access/StatsStoreCostController.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/store/access/StatsStoreCostController.java
index d36530d..a7aafb7 100644
--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/store/access/StatsStoreCostController.java
+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/store/access/StatsStoreCostController.java
@@ -345,4 +345,9 @@ public class StatsStoreCostController extends GenericController implements Store
     public int getNumPartitions() {
         return conglomerateStatistics.partitionStatistics().size();
     }
+
+    @Override
+    public double baseRowCount() {
+        return conglomerateStatistics.rowCount();
+    }
 }
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/BaseJoinSelectivityIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/BaseJoinSelectivityIT.java
new file mode 100644
index 0000000..a907b5a
--- /dev/null
+++ b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/BaseJoinSelectivityIT.java
@@ -0,0 +1,102 @@
+package com.splicemachine.db.impl.sql.compile;
+
+import com.splicemachine.derby.test.framework.SpliceUnitTest;
+import com.splicemachine.derby.test.framework.SpliceWatcher;
+import com.splicemachine.test_tools.TableCreator;
+import org.junit.BeforeClass;
+import java.sql.Connection;
+import static com.splicemachine.test_tools.Rows.row;
+import static com.splicemachine.test_tools.Rows.rows;
+
+/**
+ *
+ *
+ *
+ */
+public class BaseJoinSelectivityIT extends SpliceUnitTest {
+
+    public static void createJoinDataSet(SpliceWatcher spliceClassWatcher, String schemaName) throws Exception {
+        Connection conn = spliceClassWatcher.getOrCreateConnection();
+        new TableCreator(conn)
+                .withCreate("create table ts_10_spk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1))")
+                .withInsert("insert into ts_10_spk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false),
+                        row(6, "6", "1995-01-01 23:03:20", false),
+                        row(7, "7", "1995-01-01 23:03:20", false),
+                        row(8, "8", "1995-01-01 23:03:20", false),
+                        row(9, "9", "1995-01-01 23:03:20", false),
+                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_10_mpk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1,c2))")
+                .withInsert("insert into ts_10_mpk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false),
+                        row(6, "6", "1995-01-01 23:03:20", false),
+                        row(7, "7", "1995-01-01 23:03:20", false),
+                        row(8, "8", "1995-01-01 23:03:20", false),
+                        row(9, "9", "1995-01-01 23:03:20", false),
+                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_10_npk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null)")
+                .withInsert("insert into ts_10_npk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false),
+                        row(6, "6", "1995-01-01 23:03:20", false),
+                        row(7, "7", "1995-01-01 23:03:20", false),
+                        row(8, "8", "1995-01-01 23:03:20", false),
+                        row(9, "9", "1995-01-01 23:03:20", false),
+                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_5_spk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1))")
+                .withInsert("insert into ts_5_spk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_5_mpk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1,c2))")
+                .withInsert("insert into ts_5_mpk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_5_npk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null)")
+                .withInsert("insert into ts_5_npk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
+
+
+        conn.createStatement().executeQuery(format(
+                "call SYSCS_UTIL.COLLECT_SCHEMA_STATISTICS('%s',false)",
+                schemaName));
+        conn.commit();
+
+    }
+}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/BroadcastJoinSelectivityIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/BroadcastJoinSelectivityIT.java
new file mode 100644
index 0000000..7ab32c2
--- /dev/null
+++ b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/BroadcastJoinSelectivityIT.java
@@ -0,0 +1,61 @@
+package com.splicemachine.db.impl.sql.compile;
+
+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
+import com.splicemachine.derby.test.framework.SpliceWatcher;
+import org.junit.*;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TestRule;
+
+/**
+ *
+ *
+ *
+ */
+public class BroadcastJoinSelectivityIT extends BaseJoinSelectivityIT {
+    public static final String CLASS_NAME = BroadcastJoinSelectivityIT.class.getSimpleName().toUpperCase();
+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);
+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
+
+    @ClassRule
+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
+            .around(spliceSchemaWatcher);
+    @Rule
+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);
+
+    @BeforeClass
+    public static void createDataSet() throws Exception {
+        createJoinDataSet(spliceClassWatcher, spliceSchemaWatcher.toString());
+    }
+    @Test
+    public void innerJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_npk, ts_5_npk --splice-properties joinStrategy=BROADCAST\n where ts_10_npk.c1 = ts_5_npk.c1",methodWatcher,
+                "rows=10","BroadcastJoin");
+    }
+
+    @Test
+    public void antiJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,4},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_npk where not exists (select * from  ts_5_npk --splice-properties joinStrategy=BROADCAST\n where ts_10_npk.c1 = ts_5_npk.c1)",methodWatcher,
+                "rows=8","BroadcastAntiJoin");
+    }
+
+    @Test
+    public void leftOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_npk left outer join ts_5_npk --splice-properties joinStrategy=BROADCAST\n on ts_10_npk.c1 = ts_5_npk.c1",methodWatcher,
+                "rows=10","BroadcastLeftOuterJoin");
+    }
+
+    @Test
+    public void rightOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from ts_10_npk --splice-properties joinStrategy=BROADCAST\n right outer join ts_5_npk on ts_10_npk.c1 = ts_5_npk.c1",methodWatcher,
+                "rows=10","BroadcastRightOuterJoin");
+    }
+
+}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/JoinSelectivityIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/JoinSelectivityIT.java
deleted file mode 100644
index bfe9b4c..0000000
--- a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/JoinSelectivityIT.java
+++ /dev/null
@@ -1,133 +0,0 @@
-package com.splicemachine.db.impl.sql.compile;
-
-import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
-import com.splicemachine.derby.test.framework.SpliceUnitTest;
-import com.splicemachine.derby.test.framework.SpliceWatcher;
-import com.splicemachine.test_tools.TableCreator;
-import org.junit.*;
-import org.junit.rules.RuleChain;
-import org.junit.rules.TestRule;
-
-import java.sql.Connection;
-import java.sql.ResultSet;
-
-import static com.splicemachine.test_tools.Rows.row;
-import static com.splicemachine.test_tools.Rows.rows;
-
-/**
- *
- *
- *
- */
-public class JoinSelectivityIT extends SpliceUnitTest {
-    public static final String CLASS_NAME = JoinSelectivityIT.class.getSimpleName().toUpperCase();
-    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);
-    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
-
-    @ClassRule
-    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
-            .around(spliceSchemaWatcher);
-    @Rule
-    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);
-
-    @BeforeClass
-    public static void createDataSet() throws Exception {
-        Connection conn = spliceClassWatcher.getOrCreateConnection();
-        new TableCreator(conn)
-                .withCreate("create table ts_10_spk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1))")
-                .withInsert("insert into ts_10_spk values(?,?,?,?)")
-                .withRows(rows(
-                        row(1, "1", "1960-01-01 23:03:20", false),
-                        row(2, "2", "1980-01-01 23:03:20", false),
-                        row(3, "3", "1985-01-01 23:03:20", false),
-                        row(4, "4", "1990-01-01 23:03:20", false),
-                        row(5, "5", "1995-01-01 23:03:20", false),
-                        row(6, "6", "1995-01-01 23:03:20", false),
-                        row(7, "7", "1995-01-01 23:03:20", false),
-                        row(8, "8", "1995-01-01 23:03:20", false),
-                        row(9, "9", "1995-01-01 23:03:20", false),
-                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
-
-        new TableCreator(conn)
-                .withCreate("create table ts_10_mpk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1,c2))")
-                .withInsert("insert into ts_10_mpk values(?,?,?,?)")
-                .withRows(rows(
-                        row(1, "1", "1960-01-01 23:03:20", false),
-                        row(2, "2", "1980-01-01 23:03:20", false),
-                        row(3, "3", "1985-01-01 23:03:20", false),
-                        row(4, "4", "1990-01-01 23:03:20", false),
-                        row(5, "5", "1995-01-01 23:03:20", false),
-                        row(6, "6", "1995-01-01 23:03:20", false),
-                        row(7, "7", "1995-01-01 23:03:20", false),
-                        row(8, "8", "1995-01-01 23:03:20", false),
-                        row(9, "9", "1995-01-01 23:03:20", false),
-                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
-
-        new TableCreator(conn)
-                .withCreate("create table ts_10_npk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null)")
-                .withInsert("insert into ts_10_npk values(?,?,?,?)")
-                .withRows(rows(
-                        row(1, "1", "1960-01-01 23:03:20", false),
-                        row(2, "2", "1980-01-01 23:03:20", false),
-                        row(3, "3", "1985-01-01 23:03:20", false),
-                        row(4, "4", "1990-01-01 23:03:20", false),
-                        row(5, "5", "1995-01-01 23:03:20", false),
-                        row(6, "6", "1995-01-01 23:03:20", false),
-                        row(7, "7", "1995-01-01 23:03:20", false),
-                        row(8, "8", "1995-01-01 23:03:20", false),
-                        row(9, "9", "1995-01-01 23:03:20", false),
-                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
-
-        new TableCreator(conn)
-                .withCreate("create table ts_5_spk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1))")
-                .withInsert("insert into ts_5_spk values(?,?,?,?)")
-                .withRows(rows(
-                        row(1, "1", "1960-01-01 23:03:20", false),
-                        row(2, "2", "1980-01-01 23:03:20", false),
-                        row(3, "3", "1985-01-01 23:03:20", false),
-                        row(4, "4", "1990-01-01 23:03:20", false),
-                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
-
-        new TableCreator(conn)
-                .withCreate("create table ts_5_mpk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1,c2))")
-                .withInsert("insert into ts_5_mpk values(?,?,?,?)")
-                .withRows(rows(
-                        row(1, "1", "1960-01-01 23:03:20", false),
-                        row(2, "2", "1980-01-01 23:03:20", false),
-                        row(3, "3", "1985-01-01 23:03:20", false),
-                        row(4, "4", "1990-01-01 23:03:20", false),
-                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
-
-        new TableCreator(conn)
-                .withCreate("create table ts_5_npk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null)")
-                .withInsert("insert into ts_5_npk values(?,?,?,?)")
-                .withRows(rows(
-                        row(1, "1", "1960-01-01 23:03:20", false),
-                        row(2, "2", "1980-01-01 23:03:20", false),
-                        row(3, "3", "1985-01-01 23:03:20", false),
-                        row(4, "4", "1990-01-01 23:03:20", false),
-                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
-
-
-        conn.createStatement().executeQuery(format(
-                "call SYSCS_UTIL.COLLECT_SCHEMA_STATISTICS('%s',false)",
-                spliceSchemaWatcher));
-        conn.commit();
-
-    }
-
-    @Test
-    public void leftInnerJoinNoRelationships() throws Exception {
-        firstRowContainsQuery("explain select * from ts_10_npk, ts_5_npk where ts_10_npk.c1 = ts_5_npk.c1","rows=10",methodWatcher);
-    }
-
-    @Test
-    public void leftOuterJoinNoRelationships() throws Exception {
-        firstRowContainsQuery("explain select * from ts_10_npk left outer join ts_5_npk on ts_10_npk.c1 = ts_5_npk.c1","rows=10",methodWatcher);
-    }
-
-    @Test
-    public void leftAntiJoinNoRelationships() throws Exception {
-        firstRowContainsQuery("explain select * from ts_10_npk where not exists (select * from ts_5_npk where ts_10_npk.c1 = ts_5_npk.c1)","rows=8",methodWatcher);
-    }
-}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/JoinSelectivityNoIndexesIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/JoinSelectivityNoIndexesIT.java
new file mode 100644
index 0000000..413742e
--- /dev/null
+++ b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/JoinSelectivityNoIndexesIT.java
@@ -0,0 +1,133 @@
+package com.splicemachine.db.impl.sql.compile;
+
+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
+import com.splicemachine.derby.test.framework.SpliceUnitTest;
+import com.splicemachine.derby.test.framework.SpliceWatcher;
+import com.splicemachine.test_tools.TableCreator;
+import org.junit.*;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TestRule;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+
+import static com.splicemachine.test_tools.Rows.row;
+import static com.splicemachine.test_tools.Rows.rows;
+
+/**
+ *
+ *
+ *
+ */
+public class JoinSelectivityNoIndexesIT extends SpliceUnitTest {
+    public static final String CLASS_NAME = JoinSelectivityNoIndexesIT.class.getSimpleName().toUpperCase();
+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);
+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
+
+    @ClassRule
+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
+            .around(spliceSchemaWatcher);
+    @Rule
+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);
+
+    @BeforeClass
+    public static void createDataSet() throws Exception {
+        Connection conn = spliceClassWatcher.getOrCreateConnection();
+        new TableCreator(conn)
+                .withCreate("create table ts_10_spk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1))")
+                .withInsert("insert into ts_10_spk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false),
+                        row(6, "6", "1995-01-01 23:03:20", false),
+                        row(7, "7", "1995-01-01 23:03:20", false),
+                        row(8, "8", "1995-01-01 23:03:20", false),
+                        row(9, "9", "1995-01-01 23:03:20", false),
+                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_10_mpk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1,c2))")
+                .withInsert("insert into ts_10_mpk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false),
+                        row(6, "6", "1995-01-01 23:03:20", false),
+                        row(7, "7", "1995-01-01 23:03:20", false),
+                        row(8, "8", "1995-01-01 23:03:20", false),
+                        row(9, "9", "1995-01-01 23:03:20", false),
+                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_10_npk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null)")
+                .withInsert("insert into ts_10_npk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false),
+                        row(6, "6", "1995-01-01 23:03:20", false),
+                        row(7, "7", "1995-01-01 23:03:20", false),
+                        row(8, "8", "1995-01-01 23:03:20", false),
+                        row(9, "9", "1995-01-01 23:03:20", false),
+                        row(10, "10", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_5_spk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1))")
+                .withInsert("insert into ts_5_spk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_5_mpk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null, primary key (c1,c2))")
+                .withInsert("insert into ts_5_mpk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
+
+        new TableCreator(conn)
+                .withCreate("create table ts_5_npk (c1 int not null, c2 varchar(56) not null, c3 timestamp not null, c4 boolean not null)")
+                .withInsert("insert into ts_5_npk values(?,?,?,?)")
+                .withRows(rows(
+                        row(1, "1", "1960-01-01 23:03:20", false),
+                        row(2, "2", "1980-01-01 23:03:20", false),
+                        row(3, "3", "1985-01-01 23:03:20", false),
+                        row(4, "4", "1990-01-01 23:03:20", false),
+                        row(5, "5", "1995-01-01 23:03:20", false) )).create();
+
+
+        conn.createStatement().executeQuery(format(
+                "call SYSCS_UTIL.COLLECT_SCHEMA_STATISTICS('%s',false)",
+                spliceSchemaWatcher));
+        conn.commit();
+
+    }
+
+    @Test
+    public void leftInnerJoinNoRelationships() throws Exception {
+        firstRowContainsQuery("explain select * from ts_10_npk, ts_5_npk where ts_10_npk.c1 = ts_5_npk.c1","rows=10",methodWatcher);
+    }
+
+    @Test
+    public void leftOuterJoinNoRelationships() throws Exception {
+        firstRowContainsQuery("explain select * from ts_10_npk left outer join ts_5_npk on ts_10_npk.c1 = ts_5_npk.c1","rows=10",methodWatcher);
+    }
+
+    @Test
+    public void leftAntiJoinNoRelationships() throws Exception {
+        firstRowContainsQuery("explain select * from ts_10_npk where not exists (select * from ts_5_npk where ts_10_npk.c1 = ts_5_npk.c1)","rows=8",methodWatcher);
+    }
+}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java
new file mode 100644
index 0000000..ed217b9
--- /dev/null
+++ b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java
@@ -0,0 +1,64 @@
+package com.splicemachine.db.impl.sql.compile;
+
+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
+import com.splicemachine.derby.test.framework.SpliceWatcher;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TestRule;
+
+/**
+ *
+ *
+ *
+ */
+public class MergeJoinSelectivityIT extends BaseJoinSelectivityIT {
+    public static final String CLASS_NAME = MergeJoinSelectivityIT.class.getSimpleName().toUpperCase();
+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);
+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
+
+    @ClassRule
+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
+            .around(spliceSchemaWatcher);
+    @Rule
+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);
+
+    @BeforeClass
+    public static void createDataSet() throws Exception {
+        createJoinDataSet(spliceClassWatcher, spliceSchemaWatcher.toString());
+    }
+    @Test
+    public void innerJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=MERGE\n where ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","MergeJoin");
+    }
+
+    @Test
+    public void antiJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,4},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk where not exists (select * from  ts_5_spk --splice-properties joinStrategy=MERGE\n where ts_10_spk.c1 = ts_5_spk.c1)",methodWatcher,
+                "rows=8","MergeAntiJoin");
+    }
+
+    @Test
+    public void leftOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk left outer join ts_5_spk --splice-properties joinStrategy=MERGE\n on ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","MergeLeftOuterJoin");
+    }
+
+    @Test
+    public void rightOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from ts_10_spk --splice-properties joinStrategy=MERGE\n right outer join ts_5_spk on ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","MergeRightOuterJoin");
+    }
+
+}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/NestedLoopJoinSelectivityIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/NestedLoopJoinSelectivityIT.java
new file mode 100644
index 0000000..58459fe
--- /dev/null
+++ b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/NestedLoopJoinSelectivityIT.java
@@ -0,0 +1,64 @@
+package com.splicemachine.db.impl.sql.compile;
+
+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
+import com.splicemachine.derby.test.framework.SpliceWatcher;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TestRule;
+
+/**
+ *
+ *
+ *
+ */
+public class NestedLoopJoinSelectivityIT extends BaseJoinSelectivityIT {
+    public static final String CLASS_NAME = NestedLoopJoinSelectivityIT.class.getSimpleName().toUpperCase();
+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);
+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
+
+    @ClassRule
+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
+            .around(spliceSchemaWatcher);
+    @Rule
+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);
+
+    @BeforeClass
+    public static void createDataSet() throws Exception {
+        createJoinDataSet(spliceClassWatcher, spliceSchemaWatcher.toString());
+    }
+    @Test
+    public void innerJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=NESTEDLOOP\n where ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","NestedLoopJoin");
+    }
+
+    @Test
+    public void antiJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,4},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk where not exists (select * from  ts_5_spk --splice-properties joinStrategy=NESTEDLOOP\n where ts_10_spk.c1 = ts_5_spk.c1)",methodWatcher,
+                "rows=10","NestedLoopAntiJoin");
+    }
+
+    @Test
+    public void leftOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk left outer join ts_5_spk --splice-properties joinStrategy=NESTEDLOOP\n on ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","NestedLoopLeftOuterJoin");
+    }
+
+    @Test
+    public void rightOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from ts_10_spk --splice-properties joinStrategy=NESTEDLOOP\n right outer join ts_5_spk on ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=5","NestedLoopRightOuterJoin");
+    }
+
+}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/SortMergeJoinSelectivityIT.java b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/SortMergeJoinSelectivityIT.java
new file mode 100644
index 0000000..c1ff419
--- /dev/null
+++ b/splice_machine_test/src/test/java/com/splicemachine/db/impl/sql/compile/SortMergeJoinSelectivityIT.java
@@ -0,0 +1,64 @@
+package com.splicemachine.db.impl.sql.compile;
+
+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
+import com.splicemachine.derby.test.framework.SpliceWatcher;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TestRule;
+
+/**
+ *
+ *
+ *
+ */
+public class SortMergeJoinSelectivityIT extends BaseJoinSelectivityIT {
+    public static final String CLASS_NAME = SortMergeJoinSelectivityIT.class.getSimpleName().toUpperCase();
+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);
+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
+
+    @ClassRule
+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
+            .around(spliceSchemaWatcher);
+    @Rule
+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);
+
+    @BeforeClass
+    public static void createDataSet() throws Exception {
+        createJoinDataSet(spliceClassWatcher, spliceSchemaWatcher.toString());
+    }
+    @Test
+    public void innerJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=SORTMERGE\n where ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","MergeSortJoin");
+    }
+
+    @Test
+    public void antiJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,4},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk where not exists (select * from  ts_5_spk --splice-properties joinStrategy=SORTMERGE\n where ts_10_spk.c1 = ts_5_spk.c1)",methodWatcher,
+                "rows=8","MergeSortAntiJoin");
+    }
+
+    @Test
+    public void leftOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3},
+                "explain select * from --splice-properties joinOrder=fixed\n ts_10_spk left outer join ts_5_spk --splice-properties joinStrategy=SORTMERGE\n on ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","MergeSortLeftOuterJoin");
+    }
+
+    @Test
+    public void rightOuterJoin() throws Exception {
+        rowContainsQuery(
+                new int[] {1,3,3},
+                "explain select * from ts_10_spk --splice-properties joinStrategy=SORTMERGE\n right outer join ts_5_spk on ts_10_spk.c1 = ts_5_spk.c1",methodWatcher,
+                "rows=10","MergeSortRightOuterJoin","preds=[(TS_10_SPK.C1[4:1] = TS_5_SPK.C1[4:5])]");
+    }
+
+}
\ No newline at end of file
diff --git a/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/actions/AddColumnTransactionIT.java b/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/actions/AddColumnTransactionIT.java
index b0c3263..6e4f4dc 100644
--- a/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/actions/AddColumnTransactionIT.java
+++ b/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/actions/AddColumnTransactionIT.java
@@ -12,7 +12,6 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
@@ -416,26 +415,4 @@ public class AddColumnTransactionIT {
         Assert.assertEquals("Salary Cannot Be Queried after added!", 3,count);
     }
 
-    @Test @Ignore("DB-3711: can't add column on table with unique constraint")
-    public void testAddColAfterUniqueConstraint() throws Exception {
-        // DB-3711: add UC on a col, can't add another col
-        String tableName = "employees".toUpperCase();
-        String tableRef = schemaWatcher.schemaName+"."+tableName;
-        tableDAO.drop(schemaWatcher.schemaName, tableName);
-
-        Connection c1 = classWatcher.createConnection();
-        c1.setAutoCommit(false);
-        Statement s1 = c1.createStatement();
-
-        s1.execute(String.format("create table %s(emplid INTEGER NOT NULL, lastname VARCHAR(25) NOT NULL, firstname VARCHAR(25) NOT NULL, reportsto INTEGER)", tableRef));
-
-        c1.commit();
-
-        s1.execute(String.format("insert into %s values(7725070,'Anuradha','Kottapalli',8852090)", tableRef));
-
-        c1.commit();
-
-        s1.execute(String.format("alter table %s add constraint emp_uniq unique(emplid)", tableRef));
-        s1.execute(String.format("alter table %s add column foo int", tableRef));
-    }
 }
diff --git a/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/DistinctScalarAggregateOperationIT.java b/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/DistinctScalarAggregateOperationIT.java
index 79604b6..9aa8462 100644
--- a/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/DistinctScalarAggregateOperationIT.java
+++ b/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/DistinctScalarAggregateOperationIT.java
@@ -128,14 +128,4 @@ public class DistinctScalarAggregateOperationIT extends SpliceUnitTest {
         Assert.assertTrue("No rows returned!",rs.next());
         Assert.assertEquals("incorrect count returned",0,rs.getInt(1));
     }
-
-    @Test
-    public void testMultipleAggregate() throws Exception {
-        ResultSet rs = methodWatcher.executeQuery("select min(oid), max(oid), count(distinct catalog), sum(score)  from "+ this.getPaddedTableReference("ORDERSUMMARY"));
-        Assert.assertTrue(rs.next());
-        Assert.assertEquals(1, rs.getInt(1));
-        Assert.assertEquals(4, rs.getInt(2));
-        Assert.assertEquals(4, rs.getInt(3));
-        Assert.assertEquals(30.0, rs.getFloat(4), 0.01);
-    }
 }
diff --git a/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperationIT.java b/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperationIT.java
index cee522d..99b1364 100644
--- a/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperationIT.java
+++ b/splice_machine_test/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/export/ExportOperationIT.java
@@ -7,7 +7,6 @@ import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
 import com.splicemachine.derby.test.framework.SpliceWatcher;
 import com.splicemachine.derby.test.framework.TestConnection;
 import com.splicemachine.test_tools.TableCreator;
-import com.splicemachine.db.iapi.reference.SQLState;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
 import org.junit.ClassRule;
@@ -336,14 +335,6 @@ public class ExportOperationIT {
         } catch (SQLException e) {
             assertEquals("Invalid parameter 'cannot create export directory'='/ExportOperationIT/'.", e.getMessage());
         }
-
-        // wrong replica count
-        try {
-            methodWatcher.executeQuery("export('/tmp/', false, -100, null, null, null) select 1 from sys.sysaliases ");
-            fail();
-        } catch (SQLException e) {
-            assertEquals("Invalid error message", "XIE0U", e.getSQLState());
-        }
     }
 
 
diff --git a/splice_machine_test/src/test/java/com/splicemachine/derby/test/framework/SpliceUnitTest.java b/splice_machine_test/src/test/java/com/splicemachine/derby/test/framework/SpliceUnitTest.java
index 759a883..8e966a7 100644
--- a/splice_machine_test/src/test/java/com/splicemachine/derby/test/framework/SpliceUnitTest.java
+++ b/splice_machine_test/src/test/java/com/splicemachine/derby/test/framework/SpliceUnitTest.java
@@ -7,7 +7,6 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
-
 import org.junit.Assert;
 import org.junit.runner.Description;
 
@@ -98,6 +97,30 @@ public class SpliceUnitTest {
         rowContainsQuery(2,query,contains,methodWatcher);
     }
 
+    protected void thirdRowContainsQuery(String query, String contains,SpliceWatcher methodWatcher) throws Exception {
+        rowContainsQuery(3,query,contains,methodWatcher);
+    }
+
+    protected void fourthRowContainsQuery(String query, String contains,SpliceWatcher methodWatcher) throws Exception {
+        rowContainsQuery(4,query,contains,methodWatcher);
+    }
+
+    protected void rowContainsQuery(int[] levels, String query,SpliceWatcher methodWatcher,String... contains) throws Exception {
+        ResultSet resultSet = methodWatcher.executeQuery(query);
+        int i = 0;
+        int k = 0;
+        while (resultSet.next()) {
+            System.out.println(resultSet.getString(1));
+            i++;
+            for (int level : levels) {
+                if (level == i) {
+                    Assert.assertTrue("failed query: " + query + " -> " + resultSet.getString(1), resultSet.getString(1).contains(contains[k]));
+                    k++;
+                }
+            }
+        }
+    }
+
     protected void rowContainsQuery(int level, String query, String contains,SpliceWatcher methodWatcher) throws Exception {
         ResultSet resultSet = methodWatcher.executeQuery(query);
         for (int i = 0; i< level;i++)
