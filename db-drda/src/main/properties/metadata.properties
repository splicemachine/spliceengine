#
# This file is part of Splice Machine.
# Splice Machine is free software: you can redistribute it and/or modify it under the terms of the
# GNU Affero General Public License as published by the Free Software Foundation, either
# version 3, or (at your option) any later version.
# Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero General Public License for more details.
# You should have received a copy of the GNU Affero General Public License along with Splice Machine.
# If not, see <http://www.gnu.org/licenses/>.
#
# Some parts of this source code are based on Apache Derby, and the following notices apply to
# Apache Derby:
#
# Apache Derby is a subproject of the Apache DB project, and is licensed under
# the Apache License, Version 2.0 (the "License"); you may not use these files
# except in compliance with the License. You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.
#
# Splice Machine, Inc. has modified the Apache Derby code in this file.
#
# All such Splice Machine modifications are Copyright 2012 - 2017 Splice Machine, Inc.,
# and are licensed to you under the GNU Affero General Public License.
#
getProcedures=\
	SELECT CAST ('' AS VARCHAR(128)) AS PROCEDURE_CAT, \
		SCHEMANAME AS PROCEDURE_SCHEM, \
	    ALIAS AS PROCEDURE_NAME, \
		CAST (NULL AS INT) AS RESERVED1, CAST (NULL AS INT) AS RESERVED2, \
	    CAST (NULL AS INT) AS RESERVED3, \
		CAST ((JAVACLASSNAME||'.'|| ALIASINFO->getMethodName()) AS VARCHAR(32672)) AS REMARKS, \
		CAST (java.sql.DatabaseMetaData::procedureNoResult AS SMALLINT) AS PROCEDURE_TYPE \
	FROM SYS.SYSALIASES, SYS.SYSSCHEMAS \
	WHERE ((1=1) OR ? IS NOT NULL) \
	AND (ALIASTYPE = 'P' AND SCHEMANAME LIKE ?) \
	AND SYS.SYSALIASES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID \
	AND ALIAS LIKE ? \
	ORDER BY 2,3
# This is the JDBC 4.0 version of getProcedures, with a new name. The
# old query is kept to ensure that ODBCMetaDataGenerator will work as
# before. The old query may be removed when ODBCMetaDataGenerator is
# modified to correctly transform the new query.
getProcedures40=\
	SELECT CAST ('' AS VARCHAR(128)) AS PROCEDURE_CAT, \
		SCHEMANAME AS PROCEDURE_SCHEM, \
	    ALIAS AS PROCEDURE_NAME, \
		CAST (NULL AS INT) AS RESERVED1, CAST (NULL AS INT) AS RESERVED2, \
	    CAST (NULL AS INT) AS RESERVED3, \
		CAST ((JAVACLASSNAME||'.'|| ALIASINFO->getMethodName()) AS VARCHAR(32672)) AS REMARKS, \
		CAST (java.sql.DatabaseMetaData::procedureNoResult AS SMALLINT) AS PROCEDURE_TYPE, \
		SPECIFICNAME AS SPECIFIC_NAME \
	FROM SYS.SYSALIASES, SYS.SYSSCHEMAS \
	WHERE ((1=1) OR ? IS NOT NULL) \
	AND (ALIASTYPE = 'P' AND SCHEMANAME LIKE ?) \
	AND SYS.SYSALIASES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID \
	AND ALIAS LIKE ? \
	ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, SPECIFIC_NAME
# getSchemas
#
# parameter 1 = catalog name pattern  (not used)
# parameter 2 = schema name pattern
#
getSchemas=\
        SELECT SCHEMANAME AS TABLE_SCHEM, \
          CAST(NULL AS VARCHAR(128)) AS TABLE_CATALOG \
          FROM SYS.SYSSCHEMAS \
	  WHERE ((1=1) OR ? IS NOT NULL) \
          AND SCHEMANAME LIKE ? \
          ORDER BY TABLE_SCHEM

# REMIND: presently table_type is a single char, we match JDBC
# recommendations closer and make it a more obvious word.
# REMIND: fillers for catalog names' comparisons
# parameter 1 = catalog name pattern 
# parameter 2 = schema name pattern
# parameter 3 = table name pattern (should have like comparison)
# parameter 4,5,6,7 = a list of table types. In Derby 10.3, there
# are 4 tables types, 'T','S','V','A' and hence only 4 parameters
# are needed for table types. More information can be found in
# EmbedDatabaseMetaDate.getTables
#
# IMPORTANT NOTE:
# --------------
# DERBY-2896 
# When we add a new table type in VALUES clause below, we should  
# also add a ? in TABLETYPE IN clause. In addition, we should  
# modify EmbedDatabaseMetaData.getTables to account for that new ? 
#
getTables=\
SELECT CAST ('' AS VARCHAR(128)) AS TABLE_CAT, \
        SCHEMANAME AS TABLE_SCHEM,  \
        TABLENAME AS TABLE_NAME, \
        (CAST (RTRIM(TABLE_TYPE) AS VARCHAR(14))) \
        AS TABLE_TYPE, CAST ('' AS VARCHAR(128)) AS REMARKS, \
                CAST (NULL AS VARCHAR(128)) AS TYPE_CAT, \
                CAST (NULL AS VARCHAR(128)) AS TYPE_SCHEM, \
                CAST (NULL AS VARCHAR(128)) AS TYPE_NAME, \
                CAST (NULL AS VARCHAR(128)) AS SELF_REFERENCING_COL_NAME, \
                CAST (NULL AS VARCHAR(128)) AS REF_GENERATION, \
                CONGLOMERATENUMBER AS CONGLOM_ID \
    FROM \
         SYS.SYSTABLES LEFT OUTER JOIN SYS.SYSCONGLOMERATES \
	    ON (SYS.SYSCONGLOMERATES.TABLEID = SYS.SYSTABLES.TABLEID) \
    		AND (SYS.SYSCONGLOMERATES.ISINDEX = FALSE), \
         SYS.SYSSCHEMAS, \
         (VALUES ('T','TABLE'), ('S','SYSTEM TABLE'), ('E','EXTERNAL TABLE'), \
            ('V', 'VIEW'), ('A', 'SYNONYM')) T(TTABBREV,TABLE_TYPE) \
    WHERE (TTABBREV=TABLETYPE   \
      AND (SYS.SYSTABLES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID) \
      AND ((1=1) OR ? IS NOT NULL) \
      AND (SYS.SYSSCHEMAS.SCHEMANAME LIKE ?) \
      AND (TABLENAME LIKE ?) AND TABLETYPE IN (?, ?, ?, ?, ?)) \
      ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME

# REMIND: this query is set up to return 0 rows of the right shape, since
# there are no catalogs or metadata about them in our system yet.
# would have order by table_cat if it mattered...
# ORDER BY TABLE_CAT
getCatalogs=\
	SELECT TABLE_CAT \
	FROM ( VALUES ('') ) AS CATALOGS(TABLE_CAT) \
	WHERE (1=0)

# parameter 1 = pattern for schema (must be empty string to return rows)
# parameter 2 = pattern for procedure (method) name
# parameter 3 = pattern for column (parameter) name
#
# vti.GetProcedureColumns does not convert the case of its column names to
# the language connection context casing. So delimited identifiers must be
# used to specify these column names and display names are used so that
# the column names of the result set use the database casing.
#
#
#
getProcedureColumns=\
	SELECT CAST (NULL AS VARCHAR(128)) AS PROCEDURE_CAT, \
	    SCHEMANAME AS PROCEDURE_SCHEM, \
	    A.ALIAS AS PROCEDURE_NAME, \
	    V."COLUMN_NAME" AS COLUMN_NAME, \
	    V."COLUMN_TYPE" AS COLUMN_TYPE, \
	    V."DATA_TYPE" AS DATA_TYPE, \
	    V."TYPE_NAME" AS TYPE_NAME, \
	    V."PRECISION" AS PRECISION, \
	    V."LENGTH" AS LENGTH, \
		CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::DECIMAL, \
			java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
			java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
			java.sql.Types::BIGINT, java.sql.Types::DATE, \
			java.sql.Types::TIME, java.sql.Types::TIMESTAMP)) \
				THEN V."SCALE" \
				ELSE CAST (NULL AS SMALLINT) END \
			AS SCALE, \
		CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::DECIMAL, \
			java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
			java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
			java.sql.Types::BIGINT, java.sql.Types::DOUBLE, \
			java.sql.Types::FLOAT, java.sql.Types::REAL, \
			java.sql.Types::DATE, java.sql.Types::TIME, \
			java.sql.Types::TIMESTAMP)) \
				THEN V."RADIX" \
				ELSE CAST (NULL AS SMALLINT) END \
	    	AS RADIX, \
	    V."NULLABLE" AS NULLABLE, \
	    V."REMARKS" AS REMARKS, \
	    V."METHOD_ID" AS METHOD_ID, \
	    V."PARAMETER_ID" AS PARAMETER_ID \
	FROM \
	    SYS.SYSALIASES A, SYS.SYSSCHEMAS, \
	    NEW com.splicemachine.db.catalog.GetProcedureColumns(A.ALIASINFO, A.ALIASTYPE) V \
	WHERE \
		ALIASTYPE = 'P' AND SCHEMANAME LIKE ? \
		AND A.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID \
	    AND A.ALIAS LIKE ? AND \
            V."COLUMN_NAME" LIKE ? \
	ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, METHOD_ID, PARAMETER_ID

# This is the JDBC 4.0 version of getProcedureColumns, with a new name. The
# old query is kept to ensure that ODBCMetaDataGenerator will work as
# before. The old query may be removed when ODBCMetaDataGenerator is
# modified to correctly transform the new query.
getProcedureColumns40=\
SELECT \
	   CAST (NULL AS VARCHAR(128)) AS PROCEDURE_CAT, \
	   S.SCHEMANAME                AS PROCEDURE_SCHEM, \
	   A.ALIAS                     AS PROCEDURE_NAME, \
	   V."COLUMN_NAME"             AS COLUMN_NAME, \
	   V."COLUMN_TYPE"             AS COLUMN_TYPE, \
	   V."DATA_TYPE"               AS DATA_TYPE, \
	   V."TYPE_NAME"               AS TYPE_NAME, \
	   V."PRECISION"               AS PRECISION, \
	   V."LENGTH"                  AS LENGTH, \
 	   CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::DECIMAL, \
	   			 java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
				 java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
				 java.sql.Types::BIGINT, java.sql.Types::DATE, \
				 java.sql.Types::TIME, java.sql.Types::TIMESTAMP)) \
			THEN V."SCALE" \
			ELSE CAST (NULL AS SMALLINT) END AS SCALE, \
 	   CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::DECIMAL, \
	   			 java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
				 java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
				 java.sql.Types::BIGINT, java.sql.Types::DOUBLE, \
				 java.sql.Types::FLOAT, java.sql.Types::REAL, \
				 java.sql.Types::DATE, java.sql.Types::TIME, \
				 java.sql.Types::TIMESTAMP)) \
			THEN V."RADIX" \
			ELSE CAST (NULL AS SMALLINT) END AS RADIX, \
 	    V."NULLABLE"                AS NULLABLE, \
 	    V."REMARKS"                 AS REMARKS, \
 	    CAST (NULL AS VARCHAR(254)) AS COLUMN_DEF, \
 	    CAST (NULL AS INTEGER)      AS SQL_DATA_TYPE, \
 	    CAST (NULL AS INTEGER)      AS SQL_DATETIME_SUB, \
 	    CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::CHAR, \
			 	  java.sql.Types::VARCHAR, java.sql.Types::BINARY, \
				  java.sql.Types::VARBINARY)) \
 		THEN V."LENGTH" \
 		ELSE CAST (NULL AS INTEGER) END AS CHAR_OCTET_LENGTH, \
 		CAST ((V."PARAMETER_ID" + 1) AS INT) AS ORDINAL_POSITION, \
 		CAST ((CASE WHEN (V."NULLABLE" IN \
			 			 (java.sql.DatabaseMetaData::procedureNullable)) \
					THEN 'YES' \
					ELSE 'NO' END) AS VARCHAR(128)) AS IS_NULLABLE, \
 	    A.SPECIFICNAME   AS SPECIFIC_NAME, \
 	    V."METHOD_ID"    AS METHOD_ID, \
 	    V."PARAMETER_ID" AS PARAMETER_ID \
FROM \
	 SYS.SYSALIASES A, SYS.SYSSCHEMAS S, \
	 NEW com.splicemachine.db.catalog.GetProcedureColumns(A.ALIASINFO, A.ALIASTYPE) V \
WHERE \
	  A.ALIASTYPE = 'P' \
	  AND S.SCHEMANAME LIKE ? \
	  AND A.SCHEMAID = S.SCHEMAID \
	  AND A.ALIAS LIKE ? \
	  AND V."COLUMN_NAME" LIKE ? \
ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, SPECIFIC_NAME, METHOD_ID, PARAMETER_ID

# DB-1804 -- This query is a fix for not having implemented VTIs in Splice yet which
# the above getProcedureColumns40 query requires.  This query retrieves all of the aliases and
# their arguments/columns which are packed into the ALIAS_INFO column.  The packed ALIAS_INFO
# columns are then expanded into rows and joined with the aliases in good old Java code.
# Once we have VTIs implemented in Splice, we can remove this "code".
getProcedureColumnsPacked=\
SELECT \
	   CAST (NULL AS VARCHAR(128)) AS PROCEDURE_CAT, \
	   S.SCHEMANAME                AS PROCEDURE_SCHEM, \
	   A.ALIAS                     AS PROCEDURE_NAME, \
	   A.ALIASINFO                 AS ALIASINFO, \
	   A.ALIASTYPE                 AS ALIASTYPE, \
	   CAST (NULL AS VARCHAR(254)) AS COLUMN_DEF, \
	   CAST (NULL AS INTEGER)      AS SQL_DATA_TYPE, \
	   CAST (NULL AS INTEGER)      AS SQL_DATETIME_SUB, \
	   A.SPECIFICNAME              AS SPECIFIC_NAME \
FROM \
	 SYS.SYSALIASES A, SYS.SYSSCHEMAS S \
WHERE \
	  A.ALIASTYPE = 'P' \
	  AND S.SCHEMANAME LIKE ? \
	  AND A.SCHEMAID = S.SCHEMAID \
	  AND A.ALIAS LIKE ? \
ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, SPECIFIC_NAME

# This wants a result set with a specific column name,
# so we wrap the values in a select to name it.
getTableTypes=\
	SELECT CAST (RTRIM(TABLE_TYPE) AS VARCHAR(12)) AS TABLE_TYPE \
	FROM (VALUES 'SYNONYM', 'SYSTEM TABLE', 'TABLE', 'VIEW', 'EXTERNAL TABLE') \
		TABLETYPES(TABLE_TYPE) \
	ORDER BY TABLE_TYPE

# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
# parameter 4 = pattern for column name
# REMIND: the true or is to guard against nulls
# REMIND: need to check that sqltype column starts with SERIALIZE...
#
# DECIMAL_DIGITS returns scale for DECIMAL and NUMERIC,
# otherwise it returns null.  This is as per JavaSoft.
#
# CHAR_OCTET_LENGTH returns maximumWidth() * 2 for
# character types to account for the fact that we
# java uses 2 bytes per char and getMaximumWidth()
# returns the string length, not the length in bytes.
#
getColumns=\
 	SELECT CAST ('' AS VARCHAR(128)) AS TABLE_CAT, \
		S.SCHEMANAME AS TABLE_SCHEM, \
		T.TABLENAME AS TABLE_NAME, \
		C.COLUMNNAME AS COLUMN_NAME, \
		C.COLUMNDATATYPE.getJDBCTypeId() AS DATA_TYPE, \
		(CAST (C.COLUMNDATATYPE.getTypeName() \
		 AS VARCHAR(128))) AS TYPE_NAME, \
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::INTEGER, \
						 java.sql.Types::SMALLINT, \
						 java.sql.Types::TINYINT, \
						 java.sql.Types::BIGINT, \
						 java.sql.Types::REAL, \
						 java.sql.Types::DOUBLE,\
						 java.sql.Types::DECIMAL, \
						 java.sql.Types::NUMERIC, \
						 java.sql.Types::FLOAT)) THEN \
								C.COLUMNDATATYPE.getPrecision() ELSE \
				C.COLUMNDATATYPE.getMaximumWidth() END AS COLUMN_SIZE, \
		CAST( NULL AS INT) AS BUFFER_LENGTH, \
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::DECIMAL, 				\
			java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
			java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
			java.sql.Types::BIGINT, java.sql.Types::DATE, \
			java.sql.Types::TIME, java.sql.Types::TIMESTAMP)) \
				THEN C.COLUMNDATATYPE.getScale() \
				ELSE CAST(NULL AS INT) END \
			AS DECIMAL_DIGITS, 											\
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::REAL, 					\
			java.sql.Types::DOUBLE, java.sql.Types::FLOAT)) \
				THEN 2 \
				ELSE (CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN ( \
					java.sql.Types::INTEGER, java.sql.Types::SMALLINT, \
					java.sql.Types::TINYINT, java.sql.Types::BIGINT, \
					java.sql.Types::DECIMAL, java.sql.Types::NUMERIC, \
					java.sql.Types::DATE, java.sql.Types::TIME, \
					java.sql.Types::TIMESTAMP)) \
						THEN 10 \
						ELSE CAST (NULL AS INTEGER) END) END \
			AS NUM_PREC_RADIX, 											\
		CASE WHEN C.COLUMNDATATYPE.isNullable() THEN \
			java.sql.DatabaseMetaData::columnNullable ELSE \
			java.sql.DatabaseMetaData::columnNoNulls END AS NULLABLE, \
		CAST ('' AS VARCHAR(128)) AS REMARKS, \
		CASE WHEN (COLUMNDEFAULT IS NULL) THEN  \
		    (CASE WHEN (AUTOINCREMENTINC is NULL) THEN  \
			   CAST (NULL AS VARCHAR(254)) ELSE \
               'AUTOINCREMENT: start ' || \
                   -- The AUTOINCREMENT* columns have incorrect meta-data \n \
                   -- if the database was created with an old version of  \n \
                   -- Derby (see DERBY-1745 and DERBY-5274), and the CHAR \n \
                   -- function won't work. Wrap them in a BIGINT function \n \
                   -- call to fix the meta-data, even though the columns  \n \
                   -- already are of type BIGINT.                         \n \
							RTRIM(CHAR(BIGINT(AUTOINCREMENTSTART))) || \
							' increment ' || \
							RTRIM(CHAR(BIGINT(AUTOINCREMENTINC))) END ) ELSE \
 				CAST (COLUMNDEFAULT AS VARCHAR(254)) END AS COLUMN_DEF, \
		CAST( NULL AS INT) AS SQL_DATA_TYPE, \
		CAST( NULL AS INT) AS SQL_DATETIME_SUB, \
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::CHAR,	 				\
						 java.sql.Types::VARCHAR)) THEN \
					(CASE WHEN (C.COLUMNDATATYPE.getMaximumWidth() * 2.0 > 2147483647) THEN \
						2147483647 ELSE (C.COLUMNDATATYPE.getMaximumWidth() * 2) END) ELSE \
					CAST(NULL AS INT) END \
			AS CHAR_OCTET_LENGTH,										\
		C.COLUMNNUMBER AS ORDINAL_POSITION, \
		CAST ((CASE WHEN C.COLUMNDATATYPE.isNullable() THEN 'YES' ELSE 'NO' END) AS VARCHAR(128)) \
		 	AS IS_NULLABLE, \
                CAST (NULL AS VARCHAR(128)) AS SCOPE_CATALOG, \
                CAST (NULL AS VARCHAR(128)) AS SCOPE_SCHEMA, \
                CAST (NULL AS VARCHAR(128)) AS SCOPE_TABLE, \
                CAST (NULL AS SMALLINT) AS SOURCE_DATA_TYPE, \
                CAST ((CASE WHEN (AUTOINCREMENTINC is not NULL) THEN 'YES' ELSE 'NO' END) AS VARCHAR(128)) \
		 	AS IS_AUTOINCREMENT, \
		CAST ((CASE WHEN (C.COLUMNDEFAULT IS NOT NULL AND C.COLUMNDEFAULT.toString().startsWith( 'GENERATED ALWAYS AS' ) ) THEN 'YES' \
					ELSE  'NO' END) AS VARCHAR(128)) \
			AS IS_GENERATEDCOLUMN, \										\
                CAST (NULL AS VARCHAR(128)) AS SCOPE_CATLOG \
	FROM SYS.SYSSCHEMAS S, \
			SYS.SYSTABLES T, \
			SYS.SYSCOLUMNS C \
	WHERE C.REFERENCEID = T.TABLEID AND S.SCHEMAID = T.SCHEMAID \
	  AND ((1=1) OR ? IS NOT NULL) \
	  AND (S.SCHEMANAME LIKE ?) AND (T.TABLENAME LIKE ?) AND (C.COLUMNNAME LIKE ?) \
	ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION

# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = table name
# parameter 4 = pattern for column name
getColumnPrivileges=\
        SELECT CAST ('' AS VARCHAR(128)) AS TABLE_CAT, \
               S.SCHEMANAME AS TABLE_SCHEM, \
	       T.TABLENAME AS TABLE_NAME, \
               C.COLUMNNAME AS COLUMN_NAME, \
               CAST( P.GRANTOR AS VARCHAR(128)) AS GRANTOR, \
               CAST( P.GRANTEE AS VARCHAR(128)) AS GRANTEE, \
               CASE WHEN (P.TYPE = 's' OR P.TYPE = 'S') THEN CAST( 'SELECT' AS VARCHAR(128)) \
                  ELSE CASE WHEN (P.TYPE = 'd' OR P.TYPE = 'D') THEN CAST( 'DELETE' AS VARCHAR(128)) \
                    ELSE CASE WHEN (P.TYPE = 'i' OR P.TYPE = 'I') THEN CAST( 'INSERT' AS VARCHAR(128)) \
                      ELSE CASE WHEN (P.TYPE = 'u' OR P.TYPE = 'U') THEN CAST( 'UPDATE' AS VARCHAR(128)) \
                        ELSE CASE WHEN (P.TYPE = 'r' OR P.TYPE = 'R') THEN CAST( 'REFERENCES' AS VARCHAR(128)) \
                          ELSE CAST( 'TRIGGER' AS VARCHAR(128)) \
                          END \
                        END \
                      END \
                  END \
                END AS PRIVILEGE, \
               CASE WHEN (P.TYPE = 's' OR P.TYPE = 'd' OR P.TYPE = 'i' OR P.TYPE = 'u' OR P.TYPE = 'r' OR P.TYPE = 't') \
                    THEN CAST( 'NO' AS VARCHAR(128)) ELSE CAST( 'YES' AS VARCHAR(128)) END AS IS_GRANTABLE \
           FROM SYS.SYSCOLPERMS P, SYS.SYSCOLUMNS C, SYS.SYSTABLES T, SYS.SYSSCHEMAS S \
           WHERE P.TABLEID = T.TABLEID AND C.REFERENCEID = T.TABLEID AND S.SCHEMAID = T.SCHEMAID \
            AND ((1=1) OR ? IS NOT NULL) \
            AND (S.SCHEMANAME LIKE ?)  AND (T.TABLENAME=?) AND (C.COLUMNNAME LIKE ?) \
            AND P.COLUMNS.isSet( CAST((C.COLUMNNUMBER - 1) AS INTEGER) ) \
          ORDER BY COLUMN_NAME, PRIVILEGE

# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
getTablePrivileges=\
        SELECT CAST ('' AS VARCHAR(128)) AS TABLE_CAT, \
               S.SCHEMANAME AS TABLE_SCHEM, \
               T.TABLENAME AS TABLE_NAME, \
               CAST( P.GRANTOR AS VARCHAR(128)) AS GRANTOR, \
               CAST( P.GRANTEE AS VARCHAR(128)) AS GRANTEE, \
               X.PRIV AS PRIVILEGE, \
               X.GRANTABLE AS IS_GRANTABLE \
          FROM SYS.SYSTABLEPERMS P, SYS.SYSTABLES T, SYS.SYSSCHEMAS S, \
             (VALUES (CAST('SELECT' AS VARCHAR(128)), CAST('YES'  AS VARCHAR(128))), \
                     (CAST('SELECT' AS VARCHAR(128)), CAST('NO'  AS VARCHAR(128))), \
                     (CAST('DELETE' AS VARCHAR(128)), CAST('NO'  AS VARCHAR(128))), \
                     (CAST('DELETE' AS VARCHAR(128)), CAST('YES'  AS VARCHAR(128))), \
                     (CAST('INSERT' AS VARCHAR(128)), CAST('NO'  AS VARCHAR(128))), \
                     (CAST('INSERT' AS VARCHAR(128)), CAST('YES'  AS VARCHAR(128))), \
                     (CAST('UPDATE' AS VARCHAR(128)), CAST('NO'  AS VARCHAR(128))), \
                     (CAST('UPDATE' AS VARCHAR(128)), CAST('YES'  AS VARCHAR(128))), \
                     (CAST('REFERENCES' AS VARCHAR(128)), CAST('NO'  AS VARCHAR(128))), \
                     (CAST('REFERENCES' AS VARCHAR(128)), CAST('YES'  AS VARCHAR(128))), \
                     (CAST('TRIGGER' AS VARCHAR(128)), CAST('NO'  AS VARCHAR(128))), \
                     (CAST('TRIGGER' AS VARCHAR(128)), CAST('YES'  AS VARCHAR(128)))) AS X(PRIV,GRANTABLE) \
          WHERE P.TABLEID = T.TABLEID AND S.SCHEMAID = T.SCHEMAID \
            AND ((1=1) OR ? IS NOT NULL) \
            AND (S.SCHEMANAME LIKE ?)  AND (T.TABLENAME LIKE ?) \
            AND ((P.SELECTPRIV = 'y' AND X.PRIV = 'SELECT' AND X.GRANTABLE = 'NO') \
                 OR (P.SELECTPRIV = 'Y' AND X.PRIV = 'SELECT' AND X.GRANTABLE = 'YES') \
                 OR (P.SELECTPRIV = 'y' AND X.PRIV = 'SELECT' AND X.GRANTABLE = 'NO') \
                 OR (P.DELETEPRIV = 'Y' AND X.PRIV = 'DELETE' AND X.GRANTABLE = 'YES') \
                 OR (P.DELETEPRIV = 'y' AND X.PRIV = 'DELETE' AND X.GRANTABLE = 'NO') \
                 OR (P.INSERTPRIV = 'Y' AND X.PRIV = 'INSERT' AND X.GRANTABLE = 'YES') \
                 OR (P.INSERTPRIV = 'y' AND X.PRIV = 'INSERT' AND X.GRANTABLE = 'NO') \
                 OR (P.UPDATEPRIV = 'Y' AND X.PRIV = 'UPDATE' AND X.GRANTABLE = 'YES') \
                 OR (P.UPDATEPRIV = 'y' AND X.PRIV = 'UPDATE' AND X.GRANTABLE = 'NO') \
                 OR (P.REFERENCESPRIV = 'Y' AND X.PRIV = 'REFERENCES' AND X.GRANTABLE = 'YES') \
                 OR (P.REFERENCESPRIV = 'y' AND X.PRIV = 'REFERENCES' AND X.GRANTABLE = 'NO') \
                 OR (P.TRIGGERPRIV = 'Y' AND X.PRIV = 'TRIGGER' AND X.GRANTABLE = 'YES') \
                 OR (P.TRIGGERPRIV = 'y' AND X.PRIV = 'TRIGGER' AND X.GRANTABLE = 'NO')) \
          ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE

# This query is set up to return 0 rows of the right shape, for pre-10.2
# versions of Derby databases
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
# parameter 4 = pattern for column name
getColumnPrivileges_10_1=\
	SELECT TABLE_CAT, TABLE_SCHEM, TABLE_NAME, COLUMN_NAME, \
		GRANTOR, GRANTEE, PRIVILEGE, IS_GRANTABLE \
	FROM ( VALUES (CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128)), \
		CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128)), \
		CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128)), \
		CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128))) ) \
		AS COLUMNPRIVILEGES ( TABLE_CAT, TABLE_SCHEM, TABLE_NAME, \
			COLUMN_NAME, GRANTOR, GRANTEE, \
			PRIVILEGE, IS_GRANTABLE ) \
	WHERE (1=0) AND (((1=1) OR ? IS NOT NULL) OR ''=? OR ''=? OR ''=?)
# ORDER BY COLUMN_NAME, PRIVILEGE

# REMIND: this query is set up to return 0 rows of the right shape for
# pre-10.2 versions of Derby databases
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
getTablePrivileges_10_1=\
	SELECT TABLE_CAT, TABLE_SCHEM, TABLE_NAME, \
		GRANTOR, GRANTEE, PRIVILEGE, IS_GRANTABLE \
	FROM ( VALUES (CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128)), \
		CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128)), \
		CAST ('' AS VARCHAR(128)), CAST ('' AS VARCHAR(128)), \
		CAST ('' AS VARCHAR(128))) ) \
		AS TABLEPRIVILEGES (TABLE_CAT, TABLE_SCHEM, TABLE_NAME, \
			GRANTOR, GRANTEE, PRIVILEGE, IS_GRANTABLE ) \
	WHERE (1=0) AND (((1=1) OR ? IS NOT NULL) OR ''=? OR ''=?) \
	ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE

# REMIND: this query is set up to return 0 rows of the right shape, since
# there are none of these or metadata about them in our system yet.
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
getVersionColumns=\
	SELECT SCOPE, COLUMN_NAME, DATA_TYPE, TYPE_NAME, COLUMN_SIZE, \
		BUFFER_LENGTH, DECIMAL_DIGITS, PSEUDO_COLUMN \
	FROM ( VALUES (SMALLINT(1), CAST ('' AS VARCHAR(128)), 1, \
		 CAST ('' AS VARCHAR(128)), 1, 1, SMALLINT(1), SMALLINT(1)) ) \
		AS VERSIONCOLUMNS (SCOPE, COLUMN_NAME, DATA_TYPE, \
			TYPE_NAME, COLUMN_SIZE, BUFFER_LENGTH, \
			DECIMAL_DIGITS, PSEUDO_COLUMN ) \
	WHERE (1=0) AND (((1=1) OR ? IS NOT NULL) OR ''=? OR ''=?)

# REMIND: update query when we have catalogs and SCHEMAS
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = table name
getPrimaryKeys=\
	SELECT CAST ('' AS VARCHAR(128)) AS TABLE_CAT, \
		   S.SCHEMANAME AS TABLE_SCHEM, T.TABLENAME AS TABLE_NAME, \
		   COLS.COLUMNNAME AS COLUMN_NAME, \
		   CAST (CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) AS SMALLINT) AS KEY_SEQ, \
		   CONS.CONSTRAINTNAME AS PK_NAME \
	FROM  \
			SYS.SYSTABLES T \
			, SYS.SYSSCHEMAS S \
			, SYS.SYSCONSTRAINTS CONS \
			, SYS.SYSPRIMARYKEYS KEYS \
			, SYS.SYSCONGLOMERATES CONGLOMS \
			, SYS.SYSCOLUMNS COLS \
	WHERE ((1=1) OR ? IS NOT NULL) AND S.SCHEMANAME LIKE ? AND T.TABLENAME=? AND \
		  T.SCHEMAID = S.SCHEMAID AND	\
		  T.TABLEID = COLS.REFERENCEID AND T.TABLEID = CONGLOMS.TABLEID AND \
		  CONS.TABLEID = T.TABLEID AND CONS.TYPE = 'P' AND \
		  CONS.CONSTRAINTID = KEYS.CONSTRAINTID AND \
		  (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
				CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
				0 END) <> 0 AND \
		  KEYS.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID 

########
# getCrossReference 
# 
# This query gives information about referenced keys
# and foreign keys.  It is used to satisfy 
# and getExportedKeys() AS well as getCrossReference().
#
# NOTE: this is the same query as getImportedKeys()
# except is has a different ORDER BY and extra parameters.
#
#param1 = pattern for the PRIMARY CATALOG name 
#param2 = pattern for the PRIMARY SCHEMA name 
#param3 = PRIMARY TABLE name 
#
#param4 = pattern for the FOREIGN CATALOG name ('%' for getExportedKeys())
#param5 = pattern for the FOREIGN SCHEMA name ('%' for getExportedKeys())
#param6 = pattern for the FOREIGN TABLE name ('%' for getExportedKeys())
#  DERBY-2610: did not change from pattern matching to "T2.TABLENAME=?" 
#          because getExportedKeys uses this query with '%' for foreign table
#  Future: may want to add a new query for getExportedKeys to remove the
#          "T2.TABLENAME LIKE ?" pattern
getCrossReference=\
  SELECT \
    CAST ('' as VARCHAR(128)) as PKTABLE_CAT \
    , S.SCHEMANAME as PKTABLE_SCHEM \
    , T.TABLENAME AS PKTABLE_NAME \
    , COLS.COLUMNNAME as PKCOLUMN_NAME \
    , CAST ('' as VARCHAR(128)) as FKTABLE_CAT \
    , FKTABLE_SCHEM \
    , FKTABLE_NAME \
    , FKCOLUMN_NAME \
    , CAST (CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) as SMALLINT) as KEY_SEQ \
    , CAST ((CASE WHEN F.DELETERULE='S' \
              THEN java.sql.DatabaseMetaData::importedKeyRestrict \
              ELSE java.sql.DatabaseMetaData::importedKeyNoAction \
          END) \
      AS SMALLINT) AS UPDATE_RULE \
    , CAST ((CASE WHEN F.DELETERULE='S' \
            THEN java.sql.DatabaseMetaData::importedKeyRestrict \
            ELSE (CASE WHEN F.DELETERULE='R' \
                  THEN java.sql.DatabaseMetaData::importedKeyNoAction \
                  ELSE (CASE WHEN F.DELETERULE='C' \
                          THEN java.sql.DatabaseMetaData::importedKeyCascade \
                          ELSE (CASE WHEN F.DELETERULE='U' \
                                  THEN java.sql.DatabaseMetaData::importedKeySetNull \
                                  ELSE java.sql.DatabaseMetaData::importedKeyNoAction \
                                END) \
                        END) \
                END) \
          END) \
      AS SMALLINT) AS DELETE_RULE \
    , C.CONSTRAINTNAME as PK_NAME \
    , FK_NAME \
  FROM \
    ( SELECT \
        F2.KEYCONSTRAINTID as FK_PID \
        , C2.CONSTRAINTNAME as FK_NAME \
        , T2.TABLENAME as FKTABLE_NAME \
        , S2.SCHEMANAME as FKTABLE_SCHEM \
        , COLS2.COLUMNNAME as FKCOLUMN_NAME \
      FROM \
        SYS.SYSFOREIGNKEYS F2 \
        , SYS.SYSCONSTRAINTS C2 \
        , SYS.SYSTABLES T2 \
        , SYS.SYSSCHEMAS S2 \
        , SYS.SYSCOLUMNS COLS2 \
        , SYS.SYSCONGLOMERATES CONGLOMS2 \
      WHERE \
        F2.CONSTRAINTID = C2.CONSTRAINTID \
        AND T2.TABLEID = C2.TABLEID \
        AND S2.SCHEMAID = T2.SCHEMAID \
        AND COLS2.REFERENCEID = T2.TABLEID \
        AND CONGLOMS2.CONGLOMERATEID = F2.CONGLOMERATEID \
        AND (CASE WHEN CONGLOMS2.DESCRIPTOR IS NOT NULL THEN CONGLOMS2.DESCRIPTOR.getKeyColumnPosition(COLS2.COLUMNNUMBER) ELSE 0 END) <> 0 \
        AND ((1=1) or ? is not null) \
        AND S2.SCHEMANAME LIKE ? \
        AND T2.TABLENAME LIKE ? \
    ) as FK_INFO(FK_PID, FK_NAME,FKTABLE_NAME,FKTABLE_SCHEM,FKCOLUMN_NAME) \
    , SYS.SYSSCHEMAS S \
    , SYS.SYSTABLES T \
    , SYS.SYSCONSTRAINTS C \
    , SYS.SYSCONGLOMERATES CONGLOMS \
    , SYS.SYSCOLUMNS COLS \
    , SYS.SYSFOREIGNKEYS F \
  WHERE \
    T.SCHEMAID = S.SCHEMAID \
    AND C.TABLEID = T.TABLEID \
    AND COLS.REFERENCEID = T.TABLEID \
    AND ( \
          SELECT K.CONGLOMERATEID from SYS.SYSKEYS K where K.CONSTRAINTID = C.CONSTRAINTID \
          union all \
          SELECT PK.CONGLOMERATEID from SYS.SYSPRIMARYKEYS PK where PK.CONSTRAINTID = C.CONSTRAINTID \
    ) = CONGLOMS.CONGLOMERATEID \
    AND F.KEYCONSTRAINTID = C.CONSTRAINTID \
    and FK_INFO.FK_PID = F.KEYCONSTRAINTID \
    AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE 0 END) <> 0 \
    AND CONGLOMS.TABLEID = T.TABLEID \
  	AND ((1=1) or ? is not null) \
    AND S.SCHEMANAME LIKE ? \
    AND T.TABLENAME LIKE ? \
  ORDER BY \
    FKTABLE_CAT \
    , FKTABLE_SCHEM \
    , FKTABLE_NAME \
    , FKCOLUMN_NAME \
    , KEY_SEQ

########
# getImportedKeys 
#
# NOTE: this is the same query AS getCrossReference()
# except is has a different ORDER BY and it doesn't take
# the primary key parameters
# 
#param1 = pattern for the FOREIGN CATALOG name
#param2 = pattern for the FOREIGN SCHEMA name 
#param3 = FOREIGN TABLE name 
getImportedKeys=\
  SELECT \
    CAST ('' as VARCHAR(128)) as PKTABLE_CAT \
    , S.SCHEMANAME as PKTABLE_SCHEM \
    , T.TABLENAME AS PKTABLE_NAME \
    , COLS.COLUMNNAME as PKCOLUMN_NAME \
    , CAST ('' as VARCHAR(128)) as FKTABLE_CAT \
    , FKTABLE_SCHEM \
    , FKTABLE_NAME \
    , FKCOLUMN_NAME \
    , CAST (CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) as SMALLINT) as KEY_SEQ \
    , CAST ((CASE WHEN F.DELETERULE='S' \
              THEN java.sql.DatabaseMetaData::importedKeyRestrict \
              ELSE java.sql.DatabaseMetaData::importedKeyNoAction \
          END) \
      AS SMALLINT) AS UPDATE_RULE \
    , CAST ((CASE WHEN F.DELETERULE='S' \
            THEN java.sql.DatabaseMetaData::importedKeyRestrict \
            ELSE (CASE WHEN F.DELETERULE='R' \
                  THEN java.sql.DatabaseMetaData::importedKeyNoAction \
                  ELSE (CASE WHEN F.DELETERULE='C' \
                          THEN java.sql.DatabaseMetaData::importedKeyCascade \
                          ELSE (CASE WHEN F.DELETERULE='U' \
                                  THEN java.sql.DatabaseMetaData::importedKeySetNull \
                                  ELSE java.sql.DatabaseMetaData::importedKeyNoAction \
                                END) \
                        END) \
                END) \
          END) \
      AS SMALLINT) AS DELETE_RULE \
    , C.CONSTRAINTNAME as PK_NAME \
    , FK_NAME \
  FROM --SPLICE-PROPERTIES joinOrder=FIXED\n \
    ( SELECT \
        F2.KEYCONSTRAINTID as FK_PID \
        , C2.CONSTRAINTNAME as FK_NAME \
        , T2.TABLENAME as FKTABLE_NAME \
        , S2.SCHEMANAME as FKTABLE_SCHEM \
        , COLS2.COLUMNNAME as FKCOLUMN_NAME \
      FROM \
         SYS.SYSSCHEMAS S2 \
        , SYS.SYSTABLES T2 \
        , SYS.SYSFOREIGNKEYS F2 \
        , SYS.SYSCONSTRAINTS C2 \
        , SYS.SYSCONGLOMERATES CONGLOMS2 \
        , SYS.SYSCOLUMNS COLS2 \
      WHERE \
        F2.CONSTRAINTID = C2.CONSTRAINTID \
        AND T2.TABLEID = C2.TABLEID \
        AND S2.SCHEMAID = T2.SCHEMAID \
        AND COLS2.REFERENCEID = T2.TABLEID \
        AND CONGLOMS2.CONGLOMERATEID = F2.CONGLOMERATEID \
        AND (CASE WHEN CONGLOMS2.DESCRIPTOR IS NOT NULL THEN CONGLOMS2.DESCRIPTOR.getKeyColumnPosition(COLS2.COLUMNNUMBER) ELSE 0 END) <> 0 \
        AND ((1=1) or ? is not null) \
        AND S2.SCHEMANAME LIKE ? \
        AND T2.TABLENAME LIKE ? \
    ) as FK_INFO(FK_PID, FK_NAME,FKTABLE_NAME,FKTABLE_SCHEM,FKCOLUMN_NAME) \
    , SYS.SYSSCHEMAS S \
    , SYS.SYSTABLES T \
    , SYS.SYSFOREIGNKEYS F \
    , SYS.SYSCONSTRAINTS C \
    , SYS.SYSCONGLOMERATES CONGLOMS \
    , SYS.SYSCOLUMNS COLS \
  WHERE \
    T.SCHEMAID = S.SCHEMAID \
    AND C.TABLEID = T.TABLEID \
    AND COLS.REFERENCEID = T.TABLEID \
    AND ( \
          SELECT K.CONGLOMERATEID from SYS.SYSKEYS K where K.CONSTRAINTID = C.CONSTRAINTID \
          union all \
          SELECT PK.CONGLOMERATEID from SYS.SYSPRIMARYKEYS PK where PK.CONSTRAINTID = C.CONSTRAINTID \
    ) = CONGLOMS.CONGLOMERATEID \
    AND F.KEYCONSTRAINTID = C.CONSTRAINTID \
    and FK_INFO.FK_PID = F.KEYCONSTRAINTID \
    AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE 0 END) <> 0 \
    AND CONGLOMS.TABLEID = T.TABLEID \
  ORDER BY \
    FKTABLE_CAT \
    , FKTABLE_SCHEM \
    , FKTABLE_NAME \
    , FKCOLUMN_NAME \
    , KEY_SEQ

getTypeInfo=\
	SELECT CAST (RTRIM(CAST (T1 AS CHAR(128))) AS VARCHAR(128)) AS TYPE_NAME, \
		T2 AS DATA_TYPE, \
		T3 AS PRECISION, \
		CAST (RTRIM(CAST(T4 AS CHAR(10))) AS VARCHAR(10)) AS LITERAL_PREFIX, \
		CAST (RTRIM(T5) AS VARCHAR(10)) AS LITERAL_SUFFIX, \
		CAST (RTRIM(CAST(T6 AS CHAR(20))) AS VARCHAR(20)) AS CREATE_PARAMS, \
		CAST (T7 AS SMALLINT) AS NULLABLE, \
		T8 AS CASE_SENSITIVE, \
		CAST (T9 AS SMALLINT) AS SEARCHABLE, \
		T10 AS UNSIGNED_ATTRIBUTE, \
		T11 AS FIXED_PREC_SCALE, \
		T12 AS AUTO_INCREMENT, \
		CAST (RTRIM(CAST(T1 AS CHAR(128))) AS VARCHAR(128)) AS LOCAL_TYPE_NAME, \
		CAST (T14 AS SMALLINT) AS MINIMUM_SCALE, \
		CAST (T15 AS SMALLINT) AS MAXIMUM_SCALE, \
		CAST (NULL AS INT) AS SQL_DATA_TYPE, \
		CAST (NULL AS INT) AS SQL_DATETIME_SUB, \
		T18 AS NUM_PREC_RADIX \
	FROM ( VALUES \
		('BIGINT',-5,19,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,FALSE,FALSE,TRUE,0,0,10),\
		('LONG VARCHAR FOR BIT DATA',-4,32700,'X''','''',CAST (NULL AS CHAR), \
			1,FALSE,0,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER), \
			CAST (NULL AS INTEGER)), \
		('VARCHAR () FOR BIT DATA',-3,32672,'X''','''','length', \
			1,FALSE,2,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER), \
			CAST (NULL AS INTEGER)), \
		('CHAR () FOR BIT DATA',-2,254,'X''','''','length', \
			1,FALSE,2,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER), \
			CAST (NULL AS INTEGER)), \
		('LONG VARCHAR',-1,32700,'''','''',CAST (NULL AS CHAR), \
			1,TRUE,1,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER), \
			CAST (NULL AS INTEGER)), \
		('CHAR',1,254,'''','''','length', \
			1,TRUE,3,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER), \
			CAST (NULL AS INTEGER)), \
		('NUMERIC',2,31,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'precision,scale', \
			1,FALSE,2,FALSE,TRUE,FALSE,0,31,10),\
		('DECIMAL',3,31,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'precision,scale', \
			1,FALSE,2,FALSE,TRUE,FALSE,0,31,10),\
		('INTEGER',4,10,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,FALSE,FALSE,TRUE,0,0,10),\
		('SMALLINT',5,5,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,FALSE,FALSE,TRUE,0,0,10),\
		('FLOAT',6,52,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'precision', \
			1,FALSE,2,FALSE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),2),\
		('REAL',7,23,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,FALSE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),2),\
		('DOUBLE',8,52,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,FALSE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),2),\
		('VARCHAR',12,32672,'''','''','length', \
			1,TRUE,3,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER), \
			CAST (NULL AS INTEGER)), \
		('BOOLEAN',16,1,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER)),\
		('DATE',91,10,'DATE''','''',CAST (NULL AS CHAR), \
			1,FALSE,2,TRUE,FALSE,FALSE,0,0,10),\
		('TIME',92,8,'TIME''','''',CAST (NULL AS CHAR), \
			1,FALSE,2,TRUE,FALSE,FALSE,0,0,10),\
		('TIMESTAMP',93,29,'TIMESTAMP''','''',CAST (NULL AS CHAR), \
			1,FALSE,2,TRUE,FALSE,FALSE,0,9,10),\
		('OBJECT',2000,CAST (NULL AS INTEGER),CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,FALSE,2,TRUE,FALSE,FALSE,CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER)),\
		('BLOB',2004,2147483647,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'length', \
			1,FALSE,0,CAST (NULL AS BOOLEAN),FALSE,CAST (NULL AS BOOLEAN), \
			CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER)),\
		('CLOB',2005,2147483647,'''','''','length', \
			1,TRUE,1,CAST (NULL AS BOOLEAN),FALSE,CAST (NULL AS BOOLEAN), \
			CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER)), \
		('XML',2009,CAST (NULL AS INTEGER),CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR), \
			1,TRUE,0,FALSE,FALSE,FALSE, \
			CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER)) \
	) AS TYPEINFO(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T14,T15,T18) \
    WHERE \
        (T1 <> 'BOOLEAN' OR CAST(? AS SMALLINT) <> 0)


# parameter 1 = pattern for schema name 
# parameter 2 = pattern for table name
# parameter 3 = only get unique Indexes if TRUE
getIndexInfo=\
	SELECT CAST('' AS VARCHAR(128)) AS TABLE_CAT, \
		   S.SCHEMANAME AS TABLE_SCHEM, \
		   T.TABLENAME AS TABLE_NAME, \
		   (CASE WHEN CONGLOMS.DESCRIPTOR.isUnique() THEN FALSE ELSE TRUE END) AS NON_UNIQUE, \
		   CAST ('' AS VARCHAR(128)) AS INDEX_QUALIFIER, \
		   CONGLOMS.CONGLOMERATENAME AS INDEX_NAME, \
		   CAST (CONGLOMS.DESCRIPTOR.indexType() AS VARCHAR(128)) AS TYPE, \
		   CAST (CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) AS SMALLINT) AS ORDINAL_POSITION, \
		   COLS.COLUMNNAME AS COLUMN_NAME, \
		   CASE WHEN CONGLOMS.DESCRIPTOR.isAscending( \
				CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER)) THEN 'A' ELSE 'D' END AS ASC_OR_DESC, \
		   CAST(NULL AS INT) AS CARDINALITY, \
		   CAST(NULL AS INT) AS PAGES, \
		   CAST(NULL AS VARCHAR(128)) AS FILTER_CONDITION, \
		   CONGLOMS.CONGLOMERATENUMBER AS CONGLOM_NO \
	FROM \
			 SYS.SYSCOLUMNS COLS \n\
			,SYS.SYSTABLES T \
			,SYS.SYSCONGLOMERATES CONGLOMS \
			,SYS.SYSSCHEMAS S \
	WHERE T.TABLEID = CONGLOMS.TABLEID AND T.TABLEID = COLS.REFERENCEID \
	  AND T.SCHEMAID = S.SCHEMAID \
	  AND CONGLOMS.ISINDEX \
	  AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
				CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
				0 END) <> 0  \
	  AND S.SCHEMANAME LIKE ? AND T.TABLENAME LIKE ? \
	  AND (CASE WHEN ? THEN CONGLOMS.DESCRIPTOR.isUnique() ELSE (1=1) END) \
	ORDER BY TABLE_SCHEM, TABLE_NAME, INDEX_NAME, ORDINAL_POSITION

############################################
# 
# getBestRowIdentifier queries
#
############################################

# getBestRowIdentifierEmpty
#
# Used when bad params passed into
# getBestRowIdentifier(); return empty result set 
# of the right shape 
#
getBestRowIdentifierEmpty=\
	SELECT SCOPE, COLUMN_NAME, DATA_TYPE, TYPE_NAME, COLUMN_SIZE, \
		BUFFER_LENGTH, DECIMAL_DIGITS, PSEUDO_COLUMN \
	FROM (VALUES \
		(CAST (2  AS SMALLINT), \
		 CAST ('' AS VARCHAR(128)), \
		 0, \
		 CAST ('INT' AS VARCHAR(128)), \
		 0, \
		 0,	\
		 CAST (0 AS SMALLINT), \
		 CAST (0 AS SMALLINT)) \
		) AS BESTROWIDENTIFIER( \
		SCOPE, COLUMN_NAME, DATA_TYPE, TYPE_NAME, COLUMN_SIZE, BUFFER_LENGTH, \
		DECIMAL_DIGITS, PSEUDO_COLUMN) \
	WHERE (1=0)

# getBestRowIdentifierPrimaryKey 
#
# Find a primary key on the given table
#
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
#
getBestRowIdentifierPrimaryKey=\
	SELECT conS.CONSTRAINTID 	\
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys \
	WHERE TABS.TABLEID = conS.TABLEID \
			AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
			AND conS.CONSTRAINTID = KEYS.CONSTRAINTID \
			AND conS.type = 'P' \
			AND ((1=1) OR ? IS NOT NULL) \
			AND (SCHEMAS.SCHEMANAME LIKE ?)  \
			AND (TABS.TABLENAME=?) 

# getBestRowIdentifierPrimaryKeyColumns
#
# Return the columns that make up the primary key
#
# parameter1 - CONSTRAINTID from SYS.SYSCONSTRAINTS
# parameter2 - CONSTRAINTID from SYS.SYSKEYS
#
getBestRowIdentifierPrimaryKeyColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		COLS.COLUMNDATATYPE.getJDBCTypeId() AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST ((CASE WHEN (COLS.COLUMNDATATYPE.getJDBCTypeId() IN ( \
			java.sql.Types::DECIMAL, java.sql.Types::NUMERIC, \
			java.sql.Types::INTEGER, java.sql.Types::SMALLINT, \
			java.sql.Types::TINYINT, java.sql.Types::BIGINT, \
			java.sql.Types::DATE, java.sql.Types::TIME, \
			java.sql.Types::TIMESTAMP)) \
				THEN COLS.COLUMNDATATYPE.getPrecision() \
				ELSE CAST (NULL AS SMALLINT) END) AS SMALLINT) \
			AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys, \
		SYS.SYSCONGLOMERATES CONGLOMS, SYS.SYSCOLUMNS COLS \
	WHERE TABS.TABLEID = conS.TABLEID \
		AND TABS.TABLEID = COLS.REFERENCEID \
		AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND conS.CONSTRAINTID = ? \
		AND KEYS.CONSTRAINTID = ? \
		AND conS.CONSTRAINTID = KEYS.CONSTRAINTID \
		AND TABS.TABLEID = CONGLOMS.TABLEID \
		AND KEYS.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID \
		AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
			CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
			0 END) <> 0

# getBestRowIdentifierUniqueConstraint 
#
# See if there is a unique constraint on the given table
#
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
#
getBestRowIdentifierUniqueConstraint=\
	SELECT CONS.CONSTRAINTID, IDX.DESCRIPTOR.numberOfOrderedColumns() AS NUMCOLS \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys, SYS.SYSCONGLOMERATES IDX \
	WHERE TABS.TABLEID = conS.TABLEID AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND conS.CONSTRAINTID = KEYS.CONSTRAINTID AND IDX.DESCRIPTOR IS NOT NULL \
		AND KEYS.CONGLOMERATEID = IDX.CONGLOMERATEID AND IDX.ISCONSTRAINT \
		AND conS.type = 'U' \
		AND ((1=1) OR ? IS NOT NULL) \
		AND (SCHEMAS.SCHEMANAME LIKE ?) \
		AND (TABS.TABLENAME=?) \
	ORDER BY NUMCOLS

# getBestRowIdentifierUniqueKeyColumns
#
# Return the columns in the unique constraint
#
# parameter1 - CONSTRAINTID from SYS.SYSCONSTRAINTS
# parameter2 - CONSTRAINTID from SYS.SYSKEYS
# parameter3 - null ok
#
getBestRowIdentifierUniqueKeyColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		COLS.COLUMNDATATYPE.getJDBCTypeId() AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST ((CASE WHEN (COLS.COLUMNDATATYPE.getJDBCTypeId() IN ( \
			java.sql.Types::DECIMAL, java.sql.Types::NUMERIC, \
			java.sql.Types::INTEGER, java.sql.Types::SMALLINT, \
			java.sql.Types::TINYINT, java.sql.Types::BIGINT, \
			java.sql.Types::DATE, java.sql.Types::TIME, \
			java.sql.Types::TIMESTAMP)) \
				THEN COLS.COLUMNDATATYPE.getPrecision() \
				ELSE CAST (NULL AS SMALLINT) END) AS SMALLINT) \
			AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys, \
		SYS.SYSCONGLOMERATES CONGLOMS, SYS.SYSCOLUMNS COLS \
	WHERE TABS.TABLEID = conS.TABLEID \
		AND TABS.TABLEID = COLS.REFERENCEID \
		AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND conS.CONSTRAINTID = ? \
		AND KEYS.CONSTRAINTID = ? \
		AND conS.CONSTRAINTID = KEYS.CONSTRAINTID \
		AND TABS.TABLEID = CONGLOMS.TABLEID \
		AND KEYS.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID \
		AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
			CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
			0 END) > 0 \
		AND (?<>0 or not COLS.COLUMNDATATYPE.isNullable() ) 

# getBestRowIdentifierUniqueIndex 
#
# See if there is a unique index on the given table
#
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
#
getBestRowIdentifierUniqueIndex=\
	SELECT IDX.CONGLOMERATENUMBER, IDX.DESCRIPTOR.numberOfOrderedColumns() AS NUMCOLS \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, SYS.SYSCONGLOMERATES IDX \
	WHERE SCHEMAS.SCHEMAID = TABS.SCHEMAID and not IDX.ISCONSTRAINT \
		AND TABS.TABLEID = IDX.TABLEID  \
		AND (CASE WHEN IDX.DESCRIPTOR IS NULL THEN (1=0) ELSE IDX.DESCRIPTOR.isUnique() END)  \
		AND ((1=1) OR ? IS NOT NULL) \
		AND (SCHEMAS.SCHEMANAME LIKE ?) \
		AND (TABS.TABLENAME=?) \
	ORDER BY NUMCOLS


# getBestRowIdentifierUniqueIndexColumns
#
# Return the index columns for the given indexnumber
#
# parameter1 - index number from SYS.SYSCONSTRAINTS
# parameter2 - null ok
#
getBestRowIdentifierUniqueIndexColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		COLS.COLUMNDATATYPE.getJDBCTypeId() AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST ((CASE WHEN (COLS.COLUMNDATATYPE.getJDBCTypeId() IN ( \
			java.sql.Types::DECIMAL, java.sql.Types::NUMERIC, \
			java.sql.Types::INTEGER, java.sql.Types::SMALLINT, \
			java.sql.Types::TINYINT, java.sql.Types::BIGINT, \
			java.sql.Types::DATE, java.sql.Types::TIME, \
			java.sql.Types::TIMESTAMP)) \
				THEN COLS.COLUMNDATATYPE.getPrecision() \
				ELSE CAST (NULL AS SMALLINT) END) AS SMALLINT) \
			AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONGLOMERATES IDX, SYS.SYSCOLUMNS COLS \
	WHERE TABS.TABLEID = COLS.REFERENCEID and SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND TABS.TABLEID = IDX.TABLEID and IDX.CONGLOMERATENUMBER = ? \
		AND (CASE WHEN IDX.DESCRIPTOR IS NOT NULL THEN \
			IDX.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
			0 END) > 0 \
		AND (?<>0 or not COLS.COLUMNDATATYPE.isNullable() )

# getBestRowIdentifierAllColumns 
#
# Return all columns as the unique identifier for this table.
# Used when 
# 
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
# parameter4 - scope
# parameter5 - null ok
#
getBestRowIdentifierAllColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		COLS.COLUMNDATATYPE.getJDBCTypeId() AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST ((CASE WHEN (COLS.COLUMNDATATYPE.getJDBCTypeId() IN ( \
			java.sql.Types::DECIMAL, java.sql.Types::NUMERIC, \
			java.sql.Types::INTEGER, java.sql.Types::SMALLINT, \
			java.sql.Types::TINYINT, java.sql.Types::BIGINT, \
			java.sql.Types::DATE, java.sql.Types::TIME, \
			java.sql.Types::TIMESTAMP)) \
				THEN COLS.COLUMNDATATYPE.getPrecision() \
				ELSE CAST (NULL AS SMALLINT) END) AS SMALLINT) \
			AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS,  \
		SYS.SYSCOLUMNS COLS  \
	WHERE COLS.REFERENCEID = TABS.TABLEID  \
	  AND TABS.SCHEMAID = SCHEMAS.SCHEMAID  \
	  AND ((1=1) OR ? IS NOT NULL)  \
	  AND (SCHEMAS.SCHEMANAME LIKE ?)  \
	  AND (TABS.TABLENAME=?) \
	  AND ? BETWEEN 0 AND 2  \
	  AND (?<>0 OR NOT COLS.COLUMNDATATYPE.isNullable())

#
# getSuperTypes is not supported, so we return an empty result set of the right
# shape
#
getSuperTypes=SELECT \
        CAST(NULL AS VARCHAR(128)) AS TYPE_CAT, \
        CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM, \
        VARCHAR('', 128) AS TYPE_NAME, \
        CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_CAT, \
        CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_SCHEM, \
        VARCHAR('', 128) AS SUPERTYPE_NAME \
    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR 

getAttributes=SELECT \
        CAST(NULL AS VARCHAR(128)) AS TYPE_CAT, \
        CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM, \
        VARCHAR('', 128) AS TYPE_NAME, \
        CAST(NULL AS VARCHAR(128)) AS ATTR_NAME, \
        CAST(NULL AS INT) AS DATA_TYPE, \
        CAST(NULL AS VARCHAR(128)) AS ATTR_TYPE_NAME, \
        CAST(NULL AS INT) AS ATTR_SIZE, \
        CAST(NULL AS INT) AS DECIMAL_DIGITS, \
        CAST(NULL AS INT) AS NUM_PREC_RADIX, \
        CAST(NULL AS INT) AS NULLABLE, \
        CAST(NULL AS VARCHAR(128)) AS REMARKS, \
        CAST(NULL AS VARCHAR(128)) AS ATTR_DEF, \
        CAST(NULL AS INT) AS SQL_DATA_TYPE, \
        CAST(NULL AS INT) AS SQL_DATETIME_SUB, \
        CAST(NULL AS INT) AS CHAR_OCTET_LENGTH, \
        CAST(NULL AS INT) AS ORDINAL_POSITION, \
        CAST(NULL AS VARCHAR(128)) AS IS_NULLABLE, \
        CAST(NULL AS VARCHAR(128)) AS SCOPE_CATALOG, \
        CAST(NULL AS VARCHAR(128)) AS SCOPE_SCHEMA, \
        CAST(NULL AS VARCHAR(128)) AS SCOPE_TABLE, \
        CAST(NULL AS SMALLINT) AS SOURCE_DATA_TYPE \
    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR 

#
# getSuperTables is not supported, so we return an empty result set of the right
# shape
#
getSuperTables=SELECT \
        CAST(NULL AS VARCHAR(128)) AS TABLE_CAT, \
        CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM, \
        VARCHAR('', 128) AS TABLE_NAME, \
        VARCHAR('', 128) AS SUPERTABLE_NAME \
    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR


#
# getClientInfoProperties is not supported, so we return an empty result set
# of the right shape
#
getClientInfoProperties=SELECT \
        CAST(NULL AS VARCHAR(128)) AS NAME, \
        CAST(NULL AS INT) AS MAX_LEN, \
        CAST(NULL AS VARCHAR(128)) AS DEFAULT_VALUE, \
        CAST(NULL AS VARCHAR(128)) AS DESCRIPTION \
    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR

#
# getFunctions - From JDBC 4.0, JDK 1.6.  Returns NULL for
# catalog. Returns fully qualified method name as REMARKS 
# Param 1 catalog - dummy parameter that is not used
# Param 2 schemaPattern - NULL=>any, "" => no schema (none) 
# Param 3 functionNamePattern - NULL=>any 
# Return a result set with the right shape.
#
getFunctions=SELECT \
	CAST(NULL AS VARCHAR(128)) AS FUNCTION_CAT, \
        SYS.SYSSCHEMAS.SCHEMANAME AS FUNCTION_SCHEM, \
        SYS.SYSALIASES.ALIAS AS FUNCTION_NAME, \
        CAST ((SYS.SYSALIASES.JAVACLASSNAME || '.' || \
               SYS.SYSALIASES.ALIASINFO->getMethodName()) \
             AS VARCHAR(32672)) AS REMARKS, \
	CASE WHEN (SYS.SYSALIASES.ALIASINFO->isTableFunction())\
           THEN CAST (2 AS SMALLINT)\
           ELSE CAST (1 AS SMALLINT) \
         END AS FUNCTION_TYPE, \
        SYS.SYSALIASES.SPECIFICNAME AS SPECIFIC_NAME \
    FROM SYS.SYSSCHEMAS, SYS.SYSALIASES \
    WHERE SYS.SYSALIASES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID \
    AND SYS.SYSALIASES.ALIASTYPE = 'F' \
    AND ((1=1) OR ? IS NOT NULL) \
    AND SYS.SYSSCHEMAS.SCHEMANAME LIKE ? \
    AND SYS.SYSALIASES.ALIAS LIKE ? \
    ORDER BY FUNCTION_SCHEM, FUNCTION_NAME, SPECIFIC_NAME
#
# getFunctionColumns - From JDBC 4.0, JDK 1.6. Returns
# function parameters, including eventually, the shape
# of the ResultSet if the function returns a ResultSet.
# Param 1 catalog - dummy parameter that is not used
# Param 2 schemaPattern - NULL=>any, "" => no schema (none) 
# Param 3 functionNamePattern - NULL=>any 
# Param 4 columnNamePattern - NULL=>any 
#
getFunctionColumns=SELECT \
	CAST(NULL AS VARCHAR(128)) AS FUNCTION_CAT, \
	S.SCHEMANAME       AS FUNCTION_SCHEM, \
	A.ALIAS            AS FUNCTION_NAME, \
	V."COLUMN_NAME"    AS COLUMN_NAME, \
	V."COLUMN_TYPE"    AS COLUMN_TYPE, \
	V."DATA_TYPE"      AS DATA_TYPE, \
	V."TYPE_NAME"      AS TYPE_NAME, \
	V."PRECISION"      AS PRECISION, \
	V."LENGTH"         AS LENGTH, \
  	CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::DECIMAL, \
 		java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
 		java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
 		java.sql.Types::BIGINT, java.sql.Types::DATE, \
 		java.sql.Types::TIME, java.sql.Types::TIMESTAMP)) \
	THEN \
	V."SCALE" \
	ELSE CAST (NULL AS SMALLINT) END \
	AS SCALE, \
 	CASE WHEN (V."DATA_TYPE" IN (java.sql.Types::DECIMAL, \
 		java.sql.Types::NUMERIC, java.sql.Types::INTEGER, \
 		java.sql.Types::SMALLINT, java.sql.Types::TINYINT, \
 		java.sql.Types::BIGINT, java.sql.Types::DOUBLE, \
 		java.sql.Types::FLOAT, java.sql.Types::REAL, \
 		java.sql.Types::DATE, java.sql.Types::TIME, \
 		java.sql.Types::TIMESTAMP)) \
	THEN V."RADIX" \
	ELSE CAST (NULL AS SMALLINT) END AS RADIX, \
   	V."NULLABLE"          AS NULLABLE, \
	V."REMARKS"           AS REMARKS, \
	CASE WHEN (V."DATA_TYPE" IN ( \
		 java.sql.Types::CHAR, \
		 java.sql.Types::VARCHAR, \
		 java.sql.Types::BINARY, \
		 java.sql.Types::VARBINARY)) \
		 THEN V."LENGTH" \
		 ELSE CAST(NULL AS INT) \
	END AS CHAR_OCTET_LENGTH, \
	CASE WHEN (V."COLUMN_TYPE" = 5) \
		 THEN CAST((V."PARAMETER_ID" + 1 - V."METHOD_ID") AS INT) \
		 ELSE CAST((V."PARAMETER_ID" + 1) AS INT) \
	END AS ORDINAL_POSITION, \
	CAST(( \
	CASE \
		 WHEN V."NULLABLE" = java.sql.DatabaseMetaData::procedureNullable \
		 THEN 'YES' ELSE 'NO' \
	END) AS VARCHAR(128)) AS IS_NULLABLE, \
	A.SPECIFICNAME        AS SPECIFIC_NAME, \
	V."METHOD_ID"         AS METHOD_ID, \
	V."PARAMETER_ID"      AS PARAMETER_ID \
FROM \
     SYS.SYSALIASES A, SYS.SYSSCHEMAS S, \
     NEW com.splicemachine.db.catalog.GetProcedureColumns(A.ALIASINFO, \
                                                      A.ALIASTYPE) V \
WHERE \
      A.ALIASTYPE = 'F' \
      AND S.SCHEMANAME LIKE ? \
      AND A.SCHEMAID = S.SCHEMAID \
      AND A.ALIAS LIKE ? \
      AND (V."COLUMN_NAME" LIKE ?) \
ORDER BY FUNCTION_SCHEM, FUNCTION_NAME, SPECIFIC_NAME, PARAMETER_ID, ORDINAL_POSITION

# DB-1804 -- This query is a fix for not having implemented VTIs in Splice yet which
# the above getFunctionColumns query requires.  This query retrieves all of the aliases and
# their arguments/columns which are packed into the ALIAS_INFO column.  The packed ALIAS_INFO
# columns are then expanded into rows and joined with the aliases in good old Java code.
# Once we have VTIs implemented in Splice, we can remove this "code".
getFunctionColumnsPacked=\
SELECT \
	   CAST (NULL AS VARCHAR(128)) AS FUNCTION_CAT, \
	   S.SCHEMANAME                AS FUNCTION_SCHEM, \
	   A.ALIAS                     AS FUNCTION_NAME, \
	   A.ALIASINFO                 AS ALIASINFO, \
	   A.ALIASTYPE                 AS ALIASTYPE, \
	   A.SPECIFICNAME              AS SPECIFIC_NAME \
FROM \
	 SYS.SYSALIASES A, SYS.SYSSCHEMAS S \
WHERE \
	  A.ALIASTYPE = 'F' \
	  AND S.SCHEMANAME LIKE ? \
	  AND A.SCHEMAID = S.SCHEMAID \
	  AND A.ALIAS LIKE ? \
ORDER BY FUNCTION_SCHEM, FUNCTION_NAME, SPECIFIC_NAME

# parameter 1 = thrown away. preserved here for backward compatibility with pre-10.6 clients.
# parameter 2 = catalog name pattern 
# parameter 3 = schema name pattern (should have like comparison)
# parameter 4 = type name pattern (should have like comparison)
# parameter 5 = UDT type (JAVA_OBJECT, STRUCT, DISTINCT). In Derby 10.6, there is only one UDT type (JAVA_OBJECT)
#
# IMPORTANT NOTE:
# 
# When we add a new kind of user defined type (e.g., STRUCT or DISTINCT) to Derby, we should  
# also add a ? to the in TYPES IN clause. We should also adjust the
# values of the DATA_TYPE and BASE_TYPE columns accordingly. In addition, we should  
# modify EmbedDatabaseMetaData.getUDTs to account for that new ? 
#
getUDTs=\
	SELECT CAST (NULL AS VARCHAR(128)) AS TYPE_CAT, \
		CASE WHEN (SCHEMANAME IS NULL) THEN CAST (NULL AS VARCHAR(128)) ELSE SCHEMANAME END AS TYPE_SCHEM, \
		ALIAS AS TYPE_NAME, \
		JAVACLASSNAME AS CLASS_NAME, \
		2000 AS DATA_TYPE, \
        CAST (NULL AS VARCHAR(128)) AS REMARKS, \
        CAST (NULL AS SMALLINT) AS BASE_TYPE \
	FROM \
		 SYS.SYSALIASES, \
	     SYS.SYSSCHEMAS \
	WHERE (ALIASTYPE='A') 	\
	  AND (SYS.SYSALIASES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID) \
	  AND ((1=1) OR ? IS NOT NULL) \
	  AND ((1=1) OR ? IS NOT NULL) \
	  AND (SCHEMANAME LIKE ?) \
	  AND (ALIAS LIKE ?) AND (CAST (java.sql.Types::JAVA_OBJECT AS INTEGER) IN (?)) \
	  ORDER BY DATA_TYPE, TYPE_SCHEM, TYPE_NAME

#
# getPseudoColumns
#
# Returns an empty result set because Derby does not support pseudo columns.
#
getPseudoColumns=SELECT \
        CAST(NULL AS VARCHAR(128)) AS TABLE_CAT, \
        CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM, \
        VARCHAR('', 128) AS TABLE_NAME, \
        VARCHAR('',128) AS COLUMN_NAME, \
        CAST(1 AS INT) AS DATA_TYPE, \
        CAST(1 AS INT) AS COLUMN_SIZE, \
        CAST(NULL AS INT) AS DECIMAL_DIGITS, \
        CAST(NULL AS INT) AS NUM_PREC_RADIX, \
        VARCHAR('',128) AS COLUMN_USAGE, \
        CAST(NULL AS VARCHAR(32672)) AS REMARKS, \
        CAST(NULL AS INT) AS CHAR_OCTET_LENGTH, \
        VARCHAR('NO',128) AS IS_NULLABLE \
    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR 

