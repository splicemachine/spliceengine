package com.splicemachine.derby.impl.sql.execute.operations;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.google.common.collect.Lists;
import org.apache.log4j.Logger;
import org.junit.Assert;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.rules.TestRule;
import org.junit.runner.Description;

import com.splicemachine.derby.test.framework.SpliceDataWatcher;
import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;
import com.splicemachine.derby.test.framework.SpliceTableWatcher;
import com.splicemachine.derby.test.framework.SpliceWatcher;
import com.splicemachine.homeless.TestUtils;
import com.splicemachine.test_dao.TableDAO;

/**
 * Test to validate that GENERATED columns work correctly.
 *
 * @author Scott Fines
 * Created on: 5/28/13
 */
public class GeneratedColumnIT {
    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();
    private static final Logger LOG = Logger.getLogger(GeneratedColumnIT.class);
    private static final String CLASS_NAME = GeneratedColumnIT.class.getSimpleName().toUpperCase();

    protected  static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);
    protected static SpliceTableWatcher generatedAlwaysTable = new SpliceTableWatcher("A", schemaWatcher.schemaName,"(adr_id integer NOT NULL GENERATED ALWAYS AS IDENTITY, adr_catid integer)");
    protected static SpliceTableWatcher generatedDefaultTable = new SpliceTableWatcher("B", schemaWatcher.schemaName,"(adr_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY, adr_catid integer)");
    protected static SpliceTableWatcher generatedAlwaysTableStartsWith10 = new SpliceTableWatcher("C", schemaWatcher.schemaName,"(adr_id integer NOT NULL GENERATED ALWAYS AS IDENTITY( START WITH 10), adr_catid integer)");
    protected static SpliceTableWatcher generatedAlwaysTableIncBy10 = new SpliceTableWatcher("D", schemaWatcher.schemaName,"(adr_id integer NOT NULL GENERATED ALWAYS AS IDENTITY( INCREMENT BY 10), adr_catid integer)");

    private static int size = 10;
    @ClassRule
    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)
            .around(schemaWatcher)
            .around(generatedAlwaysTable)
            .around(generatedAlwaysTableStartsWith10)
            .around(generatedAlwaysTableIncBy10)
            .around(generatedDefaultTable)
            .around(new SpliceDataWatcher() {
                @Override
                protected void starting(Description description) {
                    try {
                        PreparedStatement ps = spliceClassWatcher.prepareStatement(String.format("insert into %s (adr_catid) values ?", generatedAlwaysTable.toString()));
                        for(int i=0;i<size;i++){
                            ps.setInt(1,i*10);
                            ps.execute();
                        }
                        ps = spliceClassWatcher.prepareStatement(String.format("insert into %s (adr_catid) values ?", generatedAlwaysTableStartsWith10));
                        for(int i=0;i<size;i++){
                            ps.setInt(1,i*10);
                            ps.execute();
                        }

												ps = spliceClassWatcher.prepareStatement(String.format("insert into %s (adr_id,adr_catid) values (DEFAULT,?)",generatedAlwaysTableStartsWith10));
												ps.setInt(1,10*size);
												ps.execute(); //make sure that we can add from default

                        ps = spliceClassWatcher.prepareStatement(String.format("insert into %s (adr_catid) values ?", generatedAlwaysTableIncBy10));
                        for(int i=0;i<size;i++){
                            ps.setInt(1,i*10);
                            ps.execute();
                        }

                        ps = spliceClassWatcher.prepareStatement(String.format("insert into %s (adr_catid) values ?",generatedDefaultTable));
                        for(int i=0;i<size/2;i++){
                            ps.setInt(1,i*10);
                            ps.execute();
                        }

                        ps = spliceClassWatcher.prepareStatement(String.format("insert into %s (adr_id,adr_catid) values (?,?)",generatedDefaultTable));
                        for(int i=size/2;i<size;i++){
                            ps.setInt(1,2*i);
                            ps.setInt(2,i*10);
                            ps.execute();
                        }

                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }finally{
                        spliceClassWatcher.closeAll();
                    }
                }
            });


    @Rule public SpliceWatcher methodWatcher = new SpliceWatcher();

    private TableDAO tableDAO;

    @Before
    public void setUp() throws Exception {
        tableDAO = new TableDAO(methodWatcher.getOrCreateConnection());
    }

    @Test
    public void testCanInsertDefaultGeneratedData() throws Exception {
        ResultSet rs = methodWatcher.executeQuery(String.format("select * from %s", generatedDefaultTable));
        List<String> results = Lists.newArrayList();
        while(rs.next()){
            Integer adrId = rs.getInt(1);

            Assert.assertTrue("No adr_id specified!",!rs.wasNull());
//            Assert.assertTrue("adrId falls in incorrect range! adrId = "+ adrId,size <= adrId || size/2 >= adrId);
            int addrCatId = rs.getInt(2);
            results.add(String.format("addrId=%d,addrCatId=%d",adrId,addrCatId));
        }
        for(String result:results){
            LOG.warn(result);
        }
        assertEquals("Incorrect number of rows returned!", size, results.size());
    }


    @Test
    public void testCanInsertGeneratedDataStartingWithValue() throws Exception {
       /*
        * Regression test for Bug 315. Make sure that the insertion which occurred during initialization is correct
        */
        ResultSet rs = methodWatcher.executeQuery(String.format("select * from %s", generatedAlwaysTableStartsWith10));
        List<String> results = Lists.newArrayList();
        while(rs.next()){
            Integer adrId = rs.getInt(1);

            Assert.assertTrue("No adr_id specified!",!rs.wasNull());
            Assert.assertTrue("adr_id outside correct range!adrId = "+ adrId,10<=adrId);
            int addrCatId = rs.getInt(2);
            results.add(String.format("addrId=%d,addrCatId=%d",adrId,addrCatId));
        }
        for(String result:results){
            LOG.debug(result);
        }
        assertEquals("Incorrect number of rows returned!", size + 1, results.size());
    }

    @Test
    public void testCanInsertGeneratedDataWithIncrement() throws Exception {
       /*
        * Regression test for Bug 315. Make sure that the insertion which occurred during initialization is correct
        */
        ResultSet rs = methodWatcher.executeQuery(String.format("select * from %s", generatedAlwaysTableIncBy10));
        List<String> results = Lists.newArrayList();
        while(rs.next()){
            Integer adrId = rs.getInt(1);

            Assert.assertTrue("No adr_id specified!",!rs.wasNull());
            Assert.assertTrue("(adrId-1)%10!=0, adrId="+adrId,(adrId-1)%10==0);
            int addrCatId = rs.getInt(2);
            results.add(String.format("addrId=%d,addrCatId=%d",adrId,addrCatId));
        }
        for(String result:results){
            LOG.debug(result);
        }
        assertEquals("Incorrect number of rows returned!", size, results.size());
    }

    @Test
    public void testCanInsertGeneratedData() throws Exception {
       /*
        * Regression test for Bug 315. Make sure that the insertion which occurred during initialization is correct
        */
        ResultSet rs = methodWatcher.executeQuery(String.format("select * from %s", generatedAlwaysTable));
        List<String> results = Lists.newArrayList();
        while(rs.next()){
            Integer adrId = rs.getInt(1);

            Assert.assertTrue("No adr_id specified!",!rs.wasNull());
            int addrCatId = rs.getInt(2);
            results.add(String.format("addrId=%d,addrCatId=%d",adrId,addrCatId));
        }
        for(String result:results){
            LOG.debug(result);
        }
        assertEquals("Incorrect number of rows returned!", size, results.size());
    }

    @Test @Ignore("DB-3656: generated column does not get updated")
    public void testUpdateGeneratedColumn() throws Exception {
        // DB-3656: generated column does not get updated
        String tableName = "words".toUpperCase();
        String tableRef = schemaWatcher.schemaName+"."+tableName;
        tableDAO.drop(schemaWatcher.schemaName, tableName);

        methodWatcher.execute(String.format("CREATE TABLE %s(WORD VARCHAR(20), UWORD GENERATED ALWAYS AS (UPPER(WORD)))",
                                            tableRef));
        methodWatcher.execute(String.format("INSERT INTO %s(WORD) VALUES 'chocolate', 'Coca-Cola', 'hamburger', " +
                                                "'carrot'",
                                            tableRef));
        // DEBUG: Remove
//        TestUtils.printResult("", methodWatcher.executeQuery(String.format("SELECT * FROM %s", tableRef)), System.out);
        ResultSet rs = methodWatcher.executeQuery(String.format("SELECT * FROM %s", tableRef));
        while (rs.next()) {
            assertEquals(rs.getString(1).toUpperCase(), rs.getString(2));
        }

    }

    @Test
    public void testInsertGeneratedUniqueData() throws Exception {
        // DB-3665: generated identity column data jumps around
        // This test shows that all values generated are unique, (at least)

        // It also shows the nature of this bug when the SQL is specified as a 1-value increment when run on a cluster
        // On a cluster, each node gets its own batch (default 1000) of in-memory sequence IDs to hand out. When more
        // than one cluster node updates a table with one of these sequences each node has a different batch of IDs to
        // hand out. Thus, These sequences may increase by the batch size of the node.
        String tableName = "t1".toUpperCase();
        String tableRef = schemaWatcher.schemaName+"."+tableName;
        tableDAO.drop(schemaWatcher.schemaName, tableName);

        methodWatcher.execute(String.format("create table %s(c1 int generated always as identity(start with 1, increment by 1), c2 int)",
                                            tableRef));
        for (int i=0; i<15; i++) {
            methodWatcher.execute(String.format("insert into %s(c2) values (8),(9)", tableRef));
            methodWatcher.execute(String.format("insert into %s(c2) select c1 from %s", tableRef,tableRef));
        }

        ResultSet rs = methodWatcher.executeQuery(String.format("SELECT * FROM %s", tableRef));
        Set<Integer> uniques = new HashSet<>();
        int i=0;
        while (rs.next()) {
            i++;
            if (uniques.contains(rs.getInt(1))) {
                fail("Duplicate identity values at "+i+": "+rs.getInt(1));
            }
            uniques.add(rs.getInt(1));
        }
        assertEquals("Expected "+i+" unique values but got "+ uniques.size(), i, uniques.size());
    }

    @Test
    public void testInsertGenerateUniqueSequencedData() throws Exception {
        // DB-3665: generated identity column data jumps around
        // This test shows that, although all sequence values are unique, they are not in sequence order (1,2,...,n).
        // TODO: This test will fail when running on a cluster

        // The bug occurs when the SQL is specified as a 1-value increment when run on a cluster
        // On a cluster, each node gets its own batch (default 1000) of in-memory sequence IDs to hand out. When more
        // than one cluster node updates a table with one of these sequences each node has a different batch of IDs to
        // hand out. Thus, these sequences may increase by the batch size of the node which may produce gaps in the
        // sequence.
        String tableName = "t2".toUpperCase();
        String tableRef = schemaWatcher.schemaName+"."+tableName;
        tableDAO.drop(schemaWatcher.schemaName, tableName);

        methodWatcher.execute(String.format("create table %s(c1 int generated always as identity(start with 1, " +
                                                "increment by 1), c2 int)",
                                            tableRef));
        for (int i=0; i<15; i++) {
            methodWatcher.execute(String.format("insert into %s(c2) values (8),(9)", tableRef));
            methodWatcher.execute(String.format("insert into %s(c2) select c1 from %s", tableRef,tableRef));
        }

        ResultSet rs = methodWatcher.executeQuery(String.format("SELECT * FROM %s order by c1", tableRef));
        int lastValue = 0;
        int i=0;
        while (rs.next()) {
            i++;
            int currentValue = rs.getInt(1);
            assertEquals("Expected " + i + " unique values but got " + currentValue, lastValue + 1, currentValue);
            lastValue = currentValue;
        }
    }

}
