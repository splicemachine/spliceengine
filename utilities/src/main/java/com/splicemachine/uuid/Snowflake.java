/*
 * Copyright (c) 2012 - 2020 Splice Machine, Inc.
 *
 * This file is part of Splice Machine.
 * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either
 * version 3, or (at your option) any later version.
 * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with Splice Machine.
 * If not, see <http://www.gnu.org/licenses/>.
 */

package com.splicemachine.uuid;

import com.splicemachine.primitives.Bytes;

import java.util.Arrays;

/**
 * An algorithm for generating compact UUIDs efficiently.
 *
 * Snowflake itself is an algorithm designed at Twitter (https://github.com/twitter/snowflake),
 * which constructs a 64-bit UUID using:
 *
 * <ol>
 *    <li>41-bit timestamp--allows ~ 69 years of unique Milliseconds before repeating</li>
 *    <li>10-bit "configured machine id" --allows 1024 machines to generate ids concurrently</li>
 *    <li>12-bit counter -- allows 4096 UUIDs to be generated every millisecond</li>
 * </ol>
 *
 * This organization is roughly time-ordered, which was a requirement for Twitter's use case, but
 * is awkward for SpliceMachine (since random UUIDs would be preferable). Additionally, 1024
 * machines is close, but may in some (highly special) cases be insufficient.
 *
 * Thus, this is an adjusted Snowflake algorithm, using similar components, but in different order
 * (to ensure randomness), and with slightly adjusted sizes.
 *
 * First, one notices that 41+10+12 = 63 bits. When considering the actual implementation
 * of Snowflake, one notices that the sign bit on the long is not used. If that bit is used,
 * an additional bit is available for use. Adding that to the machine id allows for 12 bits,
 * which allows 4096 machines to concurrently run.
 *
 * Finally, to remove the sort order, placing the counter before the timer will essentially
 * bucket UUIDs into 4096 separate buckets, which gives a much faster roll-over rate on
 * UUIDs, causing order to be removed. In summary the structure used here is:
 *
 * <ol>
 *     <li>11-bit: counter</li>
 *     <li>41-bit: timestamp</li>
 *     <li>12-bit: machineId</li>
 * </ol>
 *
 * @author Scott Fines
 * Created on: 6/21/13
 */
public class Snowflake {

    public static final long TIMESTAMP_MASK = 0x1ffffffffffl;  // 41 bits of 1s
    public static final int TIMESTAMP_SHIFT = 12;

    private static final short COUNTER_MASK = 0x07ff; // 11 bits of 1s
    private static final int COUNTER_SHIFT = 53;

    /* Mask for extracting just time timestamp portion from a long generated by this class. */
    private static final long TIMESTAMP_LOCATION = (TIMESTAMP_MASK << TIMESTAMP_SHIFT);

    /**
     * Fixed constant to allow consumers of Snowflake UUIDs to allow space in byte[] for
     * UUIDs without knowing the exact length of the UUID.
     */
    public static final int UUID_BYTE_SIZE = 8;

    private volatile long lastTimestamp = 0l;
    private volatile short counter = 0;

    private final long machineId; //only the first 12 bits are used;

    public Snowflake(short machineId) {
        this.machineId = (machineId & 0x0fff); //take the first 12 bits, then shift it over appropriately
        /*
         * We want to use -1l as a "non entry" flag, but to do so we have to ensure that it can never occur naturally.
         * If -1 occurs naturally, then we know that the counter looks like 0100 0000 0000 (e.g. 1024), and
         * both the timestamp and the machine id are 0l; Since it is possible for someone crazy to create a machine id of 0.0.0.0,
         * then reset all the system clocks to start counting from January 1, 1970, we have to watch out.
         *
         * The simplest way to do that is just to validate that we have a non-zero machine id
         */
        if(machineId==0)
            throw new IllegalArgumentException("Cannot have a machine id with all zeros!");
    }

    /**
     * Get the timestamp portion from the UUID.
     *
     * Recall that the UUID contains only 41 bits of the actual timestamp. This goes until Sep. 7, 2039,
     * so be aware.
     *
     * @param uuid the uuid to get the timestamp from
     * @return the timestamp portion of the UUID.
     */
    public static long timestampFromUUID(long uuid) {
        return (uuid & TIMESTAMP_LOCATION) >> TIMESTAMP_SHIFT;
    }

    public byte[] nextUUIDBytes(){
        return Bytes.toBytes(nextUUID());
    }

    public void nextUUIDBlock(long[] uuids){
        //we now have time
        long timestamp;
        short startCount;
        short stopCount;
        int numRecords = uuids.length;
        synchronized (this) {
            timestamp = System.currentTimeMillis();
            if(timestamp<lastTimestamp)
                throw new IllegalStateException("Unable to obtain timestamp, clock moved backwards");

            if(timestamp==lastTimestamp){
                if(counter==0)
                    while(timestamp ==lastTimestamp)
                        timestamp = System.currentTimeMillis();
            }

            if(numRecords> COUNTER_MASK-counter+1){
                numRecords = COUNTER_MASK-counter+1;
            }
            startCount = counter;
            counter+=numRecords;
            stopCount = counter;
            counter = (short)(counter & COUNTER_MASK);
            lastTimestamp = timestamp;
        }
        int pos =0;
        //noinspection ConstantConditions
        for(int i=startCount;i<stopCount;i++,pos++){
            uuids[pos] = buildUUID(timestamp,i);
        }
            /*
             * fill in any remaining entries with -1. We can safely do this because we know that
             * machine ids are never all zeros, so we can't possibly have -1 as a valid snowflake number.
             */
        if(pos<uuids.length)
            Arrays.fill(uuids,stopCount-startCount,uuids.length,-1l);
    }

    public long nextUUID(){
        long timestamp;
            /*
             * Get the timestamp to use.
             *
             * There are several reasons why we have to check against the latest timestamp:
             *
             * 1. Prevent duplicate UUIDs because we ask for too many UUIDs too frequently (unlikely,
             * since that would be asking for more than 2048 UUIDs each millisecond.
             * 2. Protect against duplicate data in the event that the system clock ran backwards.
             *
             * In the first case, we merely have to wait for the next millisecond to roll over, but the
             * second case is more problematic. If we wait for the system clock to catch up to our latest timestamp,
             * we could be waiting for days (or more, if the system clock gets badly out of alignment). More likely,
             * we'd wait for 30 seconds, and then HBase would explode, but either way, we are waiting for too
             * long--we don't want to wait more than about 20ms before exploding. Thus, we retry 10 times, waiting
             * 2 ms in between each run.
             */
        short count;
                /*
                 * When the counter goes over 11 bits, it needs to be reset. If that happens before the
                 * millisecond count can roll over, then we must block ALL threads until the millisecond clock
                 * can roll over (or we'll get duplicate UUIDs). Thus, we have to synchronize here, instead
                 * of using a non-blocking algorithm.
                 */
        synchronized (this){
            timestamp = System.currentTimeMillis();
            if(timestamp<lastTimestamp)
                throw new IllegalStateException("Unable to obtain timestamp, clock moved backwards");

            if(timestamp==lastTimestamp){
                if(counter==0)
                    while(timestamp ==lastTimestamp)
                        timestamp = System.currentTimeMillis();
            }

            count = counter;
            counter++;
            counter = (short)(counter & COUNTER_MASK);
            lastTimestamp = timestamp;
        }

        //we now have time
        return buildUUID(timestamp, count);
    }

    private long buildUUID(long timestamp, long count) {
        long uuid = count << COUNTER_SHIFT;

        uuid |= ((timestamp & TIMESTAMP_MASK) << TIMESTAMP_SHIFT);
        uuid |= machineId;
        return uuid;
    }

    public Generator newGenerator(int blockSize){
        /*
         * For correctness, we need to make sure that the Generator's block
         * size is a power of 2. So, find the smallest power of 2 large enough
         * to hold the block size in
         */
        int s = 1;
        while(s<blockSize){
            s<<=1;
        }
        return new Generator(this,s);
    }

    @Override
    public String toString() {
        return "Snowflake{" +
                "lastTimestamp=" + lastTimestamp +
                ", counter=" + counter +
                ", machineId=" + machineId +
                '}';
    }

    public static class Generator implements UUIDGenerator {
        private final Snowflake snowflake;
        private long[] currentUuids;
        private int currentPosition;

        private Generator(Snowflake snowflake, int batchSize) {
            this.snowflake = snowflake;
            this.currentPosition = batchSize+1;
            this.currentUuids = new long[batchSize];
        }

        public long next(){
            if(currentPosition>=currentUuids.length||currentUuids[currentPosition]==-1l)
                refill();
            int pos = currentPosition;
            currentPosition++;
            return currentUuids[pos];
        }

        @Override public byte[] nextBytes(){ return Bytes.toBytes(next()); }
        @Override public int encodedLength() { return 8; }

        @Override
        public void next(byte[] data, int offset) {
            long nextLong = next();
            Bytes.toBytes(nextLong, data, offset);
        }

        private void refill(){
            snowflake.nextUUIDBlock(currentUuids);
            currentPosition=0;
        }
    }

    @SuppressWarnings("unused")
    private static String pad(long number){
        String binary = Long.toBinaryString(number);
        char[] zeros = new char[Long.numberOfLeadingZeros(number)];
        for(int i=0;i<zeros.length;i++){
            zeros[i] = '0';
        }
        return new String(zeros)+binary;
    }

}
