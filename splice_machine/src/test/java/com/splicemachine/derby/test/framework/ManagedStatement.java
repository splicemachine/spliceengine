/*
 * Copyright (c) 2012 - 2020 Splice Machine, Inc.
 *
 * This file is part of Splice Machine.
 * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License as published by the Free Software Foundation, either
 * version 3, or (at your option) any later version.
 * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with Splice Machine.
 * If not, see <http://www.gnu.org/licenses/>.
 */

package com.splicemachine.derby.test.framework;

import splice.com.google.common.collect.Lists;

import java.sql.*;
import java.util.List;

/**
 * @author Scott Fines
 *         Date: 8/4/14
 */
public class ManagedStatement implements Statement {
    private final Statement statement;
    private final List<ResultSet> resultSets = Lists.newArrayList();

    public ManagedStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        ResultSet resultSet = statement.executeQuery(sql);
        resultSets.add(resultSet);
        return resultSet;
    }

    @Override public int executeUpdate(String sql) throws SQLException { return statement.executeUpdate(sql); }

    @Override
    public void close() throws SQLException {
        for(ResultSet rs: resultSets){
           rs.close();
        }
        statement.close();
    }

    @Override public int getMaxFieldSize() throws SQLException { return statement.getMaxFieldSize(); }
    @Override public void setMaxFieldSize(int max) throws SQLException { statement.setMaxFieldSize(max); }
    @Override public int getMaxRows() throws SQLException { return statement.getMaxRows(); }
    @Override public void setMaxRows(int max) throws SQLException { statement.setMaxRows(max); }
    @Override public void setEscapeProcessing(boolean enable) throws SQLException { statement.setEscapeProcessing(enable); }
    @Override public int getQueryTimeout() throws SQLException { return statement.getQueryTimeout(); }
    @Override public void setQueryTimeout(int seconds) throws SQLException { statement.setQueryTimeout(seconds); }
    @Override public void cancel() throws SQLException { statement.cancel(); }
    @Override public SQLWarning getWarnings() throws SQLException { return statement.getWarnings(); }
    @Override public void clearWarnings() throws SQLException { statement.clearWarnings(); }
    @Override public void setCursorName(String name) throws SQLException { statement.setCursorName(name); }
    @Override public boolean execute(String sql) throws SQLException { return statement.execute(sql); }

    @Override
    public ResultSet getResultSet() throws SQLException {
        ResultSet resultSet = statement.getResultSet();
        resultSets.add(resultSet);
        return resultSet;
    }

    @Override public int getUpdateCount() throws SQLException { return statement.getUpdateCount(); }
    @Override public boolean getMoreResults() throws SQLException { return statement.getMoreResults(); }
    @Override public void setFetchDirection(int direction) throws SQLException { statement.setFetchDirection(direction); }
    @Override public int getFetchDirection() throws SQLException { return statement.getFetchDirection(); }
    @Override public void setFetchSize(int rows) throws SQLException { statement.setFetchSize(rows); }
    @Override public int getFetchSize() throws SQLException { return statement.getFetchSize(); }
    @Override public int getResultSetConcurrency() throws SQLException { return statement.getResultSetConcurrency(); }
    @Override public int getResultSetType() throws SQLException { return statement.getResultSetType(); }
    @Override public void addBatch(String sql) throws SQLException { statement.addBatch(sql); }
    @Override public void clearBatch() throws SQLException { statement.clearBatch(); }
    @Override public int[] executeBatch() throws SQLException { return statement.executeBatch(); }
    @Override public Connection getConnection() throws SQLException { return statement.getConnection(); }
    @Override public boolean getMoreResults(int current) throws SQLException { return statement.getMoreResults(current); }

    @Override public ResultSet getGeneratedKeys() throws SQLException {
        ResultSet generatedKeys = statement.getGeneratedKeys();
        resultSets.add(generatedKeys);
        return generatedKeys;
    }
    @Override public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException { return statement.executeUpdate(sql, autoGeneratedKeys); }
    @Override public int executeUpdate(String sql, int[] columnIndexes) throws SQLException { return statement.executeUpdate(sql, columnIndexes); }
    @Override public int executeUpdate(String sql, String[] columnNames) throws SQLException { return statement.executeUpdate(sql, columnNames); }
    @Override public boolean execute(String sql, int autoGeneratedKeys) throws SQLException { return statement.execute(sql, autoGeneratedKeys); }
    @Override public boolean execute(String sql, int[] columnIndexes) throws SQLException { return statement.execute(sql, columnIndexes); }
    @Override public boolean execute(String sql, String[] columnNames) throws SQLException { return statement.execute(sql, columnNames); }
    @Override public int getResultSetHoldability() throws SQLException { return statement.getResultSetHoldability(); }
    @Override public boolean isClosed() throws SQLException { return statement.isClosed(); }
    @Override public void setPoolable(boolean poolable) throws SQLException { statement.setPoolable(poolable); }
    @Override public boolean isPoolable() throws SQLException { return statement.isPoolable(); }

    public void closeOnCompletion() throws SQLException {
//        statement.closeOnCompletion();
    }
    public boolean isCloseOnCompletion() throws SQLException {
        return false;
//        return statement.isCloseOnCompletion();
    }
    @Override public <T> T unwrap(Class<T> iface) throws SQLException { return statement.unwrap(iface); }
    @Override public boolean isWrapperFor(Class<?> iface) throws SQLException { return statement.isWrapperFor(iface); }
}
